### 1.3 网络编程

>date: 2019-01-24

![](../assets/images/13.jpg)

#### 1.3.1 计算机网络体系

计算机网络体现结构分为3种：`OSI`体系结构、`TCP/IP`体系结构、五层体系结构

![计算机网络体系结构](../assets/images/131_01.jpg)

* `OSI`七层协议

>1) 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做**比特**。
>
>2) 数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。
>
>3) 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
>
>4) 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。
>
>5) 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。
>
>6)表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。
>
>7) 应用层： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。

* `TCP/IP`四层协议

>1) 网络接口层：对应着OSI的物理层和数据链路层，负责通过网络发送和接收IP数据报。
>
>2) 网际层：也称互联层、网间网层，主要功能是处理来自传输层的分组，将分组形成数据包（IP数据包），并为该数据包进行路径选择，最终将数据包从源主机发送到目的主机。常用的协议是网际协议IP协议。
>
>3) 运输层：又称为主机至主机层，与OSI传输层类似，负责主机到主机之间的端到端通信，使用传输控制协议TCP协议和用户数据包协议UDP协议。
>
>4) 应用层：与OSI模型中的高三层任务相同，用于提供网络服务。

* 五层协议

>1) 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。
>
2) 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组封装成帧。
>
>3) 网络层：为主机之间提供数据传输服务，而像运输层协议那样是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。
>
>4) 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。`TCP`主要提供完整性服务，UDP 主要提供及时性服务。
>
>5) 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。

#### 1.3.2 OSI和TCP/IP的区别

* `TCP/IP`协议族

互联网协议族（英语：`Internet Protocol Suite`，缩写`IPS`）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为`TCP/IP`协议族（英语：`TCP/IP Protocol Suite`，或`TCP/IP Protocols`），简称`TCP/IP`。因为该协议家族的两个核心协议：`TCP`（传输控制协议）和`IP`（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为`TCP/IP`协议栈（英语：`TCP/IP Protocol Stack`）。

`TCP/IP`提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议套组下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层`OSI`模型。

![TCP/IP 协议族体系结构以及主要协议](../assets/images/132_01.png)

`OSI`七层协议比`TCP/IP`出现的晚，相较之下`TCP/IP`协议更加轻盈，并且在业界已经广泛应用，所以在现在人们更多讨论的是`TCP/IP`协议。同时`TCP/IP`协议并没有完全匹配上`OSI`协议，`TCP/IP`协议是用来解决一系列具体问题，而`OSI`协议只是对互联网通信的一个宽泛的描述。

#### 1.3.3 TCP协议

传输控制协议（英文：`Transmission Control Protocol`，缩写`TCP`）属于传输层通信协议。基于`TCP`的应用层协议有`HTTP`、`SMTP`、`FTP`、`Telnet`、`POP3`等。

`TCP`提供一种 **面向连接的、可靠、全双工通信** 的字节流服务。在一个 `TCP`连接中，仅有两方进行彼此通信。广播和多播不能用于`TCP`。`TCP`还使用校验和来确认和重传机制来保证可靠传输。`TCP`给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复。`TCP`使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制。

`TCP`并不能保证数据一定会被对方接收到，因为这是不可能的。`TCP`能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 `TCP`也不是`100%`可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

##### `TCP`的三次握手和四次挥手

`报文段 = 首部 + 数据 2 部分`

![TCP报文结构](../assets/images/133_01.png)

常见状态位：

`SYN`（`Synchronize Sequence Numbers`，同步序列编号）：发起一个连接；
`ACK`（`Acknowledgement`，确认字符）：回复；
`RST`（`Connection reset`）：重新连接；
`FIN`：结束连接。

`TCP`报文段很复杂，主要关注五个问题：顺序问题、丢包问题、连接维护、流量控制、拥塞控制。

![三次握手](../assets/images/133_02.png)

三次握手，指的是建立一个`TCP`连接时，需要客户端和服务端总共发3个包。

* 初始状态：客户端、服务端都处于关闭状态（CLOSED）；
* 直到：客户端主动打开连接，服务端处于监听状态（LISTEN），等待接收客户端请求；
* 第一次握手：客户端向服务端发送1个连接请求的报文段（不携带数据）。同步标志位SYN=1，随机选择一个起始序号seq=x。客户端进入同步已发送（SYN_SEND）状态；
* 第二次握手：服务端收到请求连接报文段后（不携带数据），若同意建立连接，则向客户端发回连接确认的报文段。同步标志位SYN=1，确认标志位ACK=1，随机选择一个起始序号seq=y，确认号字段设为ack=x+1。服务端进入同步已接收（SYN_RCVD）状态；
* 第三次握手：客户端收到确认报文段后，向服务端再次发出连接确认报文段（可携带数据）。确认标注为ACK=1，序号seq=x+1，确认号字段设为ack=y+1。客户端、服务端都进入已创建（ESTABLISHED）状态。

![四次挥手](../assets/images/133_03.png)

四次挥手，`TCP`连接的拆除需要发送4个包，其中客户端和服务端均可主动发起挥手动作。

* 初始状态：`TCP`客户端、服务端都处于已创建状态（ESTABLISHED）；
* 直到：客户端主动关闭`TCP`连接；
* 第一次挥手：客户端向向服务端发送1个连接释放的报文段（可携带数据，停止再发送数据）。终止控制位FIN=1，报文段序号设为前面传送数据最后一个字节的序号加1，seq=u。
* 第二次挥手：服务段收到连接释放报文段后，泽祥客户端发回连接释放确认的报文段。确认标记为ACK=1，报文段序号设为前面传送数据最后一个字节的序号加1，seq=v，确认号字段ack=u+1；服务端进入关闭等待状态（CLOSE-WAIT），客户端接收到服务器确认后，进入终止等待状态FIN-WAIT-2，等待服务端发出释放连接请求；至此，客户端-->服务端的`TCP`连接已断开，`TCP`处于半关闭状态，服务端-->客户端未断开；
* 第三次挥手：若服务端已无要向客户端发送数据，则发送释放连接的报文段（可携带数据）。种种控制位FIN=1，确认标记位ACK=1，报文段序号seq=w，重复上次已发送的确认号字段ack=u+1；服务器进入最后确认状态（LAST-WAIT）；
* 第四次挥手：客户端收到连接释放报文段后，则向服务端发回连接释放确认的报文段（可携带数据）。确认标记位ACK=1，报文段序号seq=u+1，确认号字段ack=w+1；客户端进入时间等待状态（TIME-WAIT），服务端进入关闭状态（CLOSED），此时`TCP`连接还未释放，须经过时间等待计时器设置的时间2MSL（MSL, Maximum Segment Lifetime最长报文段寿命）后，客户端才进入连接关闭状态（CLOSED）。

![TCP状态图](../assets/images/133_04.png)

* 阿拉伯数字序号：建立连接顺序；
* 大写中文数字序号：断开连接顺序；
* 加粗实线：客户端 `A` 的状态变迁；
* 加粗虚线：服务端 `B` 的状态变迁。

#### 1.3.4 UDP协议

用户数据报协议（英文：`User Datagram Protocol`，缩写`UDP`）属于传输层通信协议。基于`UDP`的应用层协议有`TFTP`、`SNMP`、`DNS`等。

`UDP`是 **无连接的、不可靠、面向报文、无拥塞控制** 的传输层协议。`UDP`数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。`UDP`通讯时不需要接收方确认，属于不可靠的传输，可能会出丢包现象，实际应用中要求程序员编程验证。`UDP`与`TCP`位于同一层，但它不管数据包的顺序、错误或重发。

![UDP报文段结构](../assets/images/134_01.png)

* `TCP`、`UDP`协议的区别

![TCP、UDP协议区别](../assets/images/134_02.png)

1) `TCP`面向连接，`UDP`不面向连接。
2) `TCP`面向字节，不存在消息边界，可能存在**粘包**问题。`UDP`则面向报文。
3) `TCP`会尽力保证数据的可靠交付，而`UDP`默认不做保证。
4) `TCP`头部`20`字节，`UDP`头部`8`字节。

*粘包：`TCP`并不知道所传输的字节流的含义，`TCP`并不能保证接收方应用程序和发送方应用程序所发出的数据块具有对应大小的关系*

#### 1.3.5 HTTP协议

超文本传输协议（英文：`Hyper Text Transfer Protocol`，缩写`HTTP`）是用于传输诸如HTML的超媒体文档的应用层协议。

`HTTP`是 **无连接、无状态** 的，它采用 **请求/响应** 的工作方式，具体工作流程如下：

![HTTP工作流程](../assets/images/135_01.png)

`HTTP`报文分为请求报文和响应报文，分别用于发送请求和响应请求。

##### 请求报文

报文结构：由请求行、请求头、请求体组成

```html
GET /hello.htm HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
Host: example.com
Accept-Language: en-us
Accept-Encoding: gzip, deflate
```

![请求报文结构](../assets/images/135_02.png)

![请求行结构](../assets/images/135_03.png)

* `GET`和`POST`方法的区别：

1) 传递参数的长度限制：`GET`发送的数据存放在`URL`中，直到附加在`URL`后，利用一个`?`代表`URL`结束和请求参数的开始；`URL`的长度是受限制的（最大长度为2048个字符）。`POST`方法没有这些限制。

2) 传递参数的数据类型：`GET`传递的参数只允许`ASCII`字符。`POST`参数允许任何类型。

3) 安全性：`GET`方法的数据直接添加到`URL`中，安全性差。`POST`方法的数据封装在请求数据中，浏览器无缓存，安全性好。

`GET`方法应用于小量、数据不敏感，具体向指定资源请求数据上，而`POST`方法应用于大量、数据敏感，具体向指定资源提交数据。

* 请求体请求数据的使用方式共`3`种:

1) 数据交换：请求体可以是任意类型，但需要服务端进行解析。

2) 键值对：键值之间用`=`连接，每个键值对间用`&`连接。

3) 分部分提供：请求体被分为多个部分，每一段以`{boundary}`开头 + 描述头 + 空行 + 内容 + `{boundary}`结束。

* 资源标示符

`URI`：`Uniform Resource Identifier`，统一资源标识符。
`URL`：`Uniform Resource Locator`，统一资源定位符。
`URN`：`Uniform Resource Name`，统一资源名称。

`URL`和`URN`都属于`URI`。
`URI`和`URL`的区别是：`URL`更具体。`URI`和`URL`都定义了什么是资源。但`URL`还定义了如何获得资源。

##### 响应报文

报文结构：由状态行、响应头、响应体组成

```html
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache/2.2.14 (Win32)
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
Content-Length: 88
Content-Type: text/html
Connection: Closed

<html>
   <body>

   <h1>Hello, World!</h1>

   </body>
</html>
```

![响应报文结构](../assets/images/135_04.png)

![状态行结构](../assets/images/135_05.png)

#### 1.3.6 FTP和SMTP协议

##### FTP协议

文件传输协议（英文：`File Transfer Protocol`，缩写`FTP`）是`TCP/IP`协议组中的协议之一。`FTP`协议包括两个组成部分，其一为`FTP`服务器，其二为`FTP`客户端。其中`FTP`服务器用来存储文件，用户可以使用`FTP`客户端通过FTP协议访问位于`FTP`服务器上的资源。在开发网站的时候，通常利用`FTP`协议把网页或程序传到`Web`服务器上。此外，由于`FTP`传输效率非常高，在网络上传输大的文件时，一般也采用该协议。

默认情况下`FTP`协议使用`TCP`端口中的`20`和`21`这两个端口，其中`20`用于传输数据，`21`用于传输控制信息。但是，是否使用`20`作为传输数据的端口与`FTP`使用的传输模式有关，如果采用主动模式，那么数据传输端口就是`20`；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。

##### SMTP协议

简单邮件传输协议（英文：`Simple Mail Transfer Protocol`，缩写`SMTP`）是在`Internet`传输`email`的事实标准。

`SMTP`是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过`telnet`程序来测试一个`SMTP`服务器。`SMTP`使用`TCP`端口`25`。要为一个给定的域名决定一个`SMTP`服务器，需要使用`MX (Mail eXchange)DNS`。

由于这个协议开始是基于纯`ASCII`文本的，它在二进制文件上处理得并不好。诸如`MIME`的标准被开发来编码二进制文件以使其通过`SMTP`来传输。今天，大多数`SMTP`服务器都支持`8`位`MIME`扩展，它使二进制文件的传输变得几乎和纯文本一样简单。

`SMTP`是一个“推”的协议，它不允许根据需要从远程服务器上“拉”来消息。要做到这点，邮件客户端必须使用`POP3`或`IMAP`。另一个`SMTP`服务器可以使用`ETRN`在`SMTP`上触发一个发送。

#### 1.3.7 DNS协议

域名系统（英文：`Domain Name System`，缩写：`DNS`）是将人类可读的域名 (如，`www.example.com`) 转换为机器可读的`IP`地址的服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。`DNS`使用`TCP`和`UDP`端口`53`。当前，对于每一级域名长度的限制是`63`个字符，域名总长度则不能超过`253`个字符。

#### 1.3.8 Socket编程

##### 基于TCP

* `TCP`服务端

```python
from socket import socket, AF_INET, SOCK_STREAM

def echo_handler(address, client_sock):
    print('Got connection from {}'.format(address))
    while True:
        msg = client_sock.recv(8192) # 接收请求数据
        print('Message:', msg)
        if not msg:
            break
        client_sock.sendall(msg) # 处理并发送请求数据
    client_sock.close() # 通信完毕, 关闭链接

def echo_server(address, backlog=5):
    sock = socket(AF_INET, SOCK_STREAM) # 创建套接字对象 创建socket对象
    sock.bind(address) # 绑定IP和端口
    sock.listen(backlog) # 开始监听链接
    while True:
        client_sock, client_addr = sock.accept() # 阻塞 , 等待客户端成功连接
        echo_handler(client_addr, client_sock)

if __name__ == '__main__':
    echo_server(('', 20000))
```

* `TCP`客户端

```python
from socket import socket, AF_INET, SOCK_STREAM

s = socket(AF_INET, SOCK_STREAM) # 创建套接字对象
s.connect(('localhost', 20000)) # 连接服务端
s.send(b'Hello') # 发送请求数据
content = s.recv(8192) # 接收请求数据
print(content.decode())
s.close() # 通信完毕,关闭套接字
```

##### 基于UDP

* `UDP`服务端

```python
from socket import socket, AF_INET, SOCK_DGRAM
import time

def time_server(address):
    sock = socket(AF_INET, SOCK_DGRAM) # 创建套接字对象
    sock.bind(address) # 绑定IP和端口
    while True:
        msg, addr = sock.recvfrom(8192) # 接收请求数据
        print('Got message from', addr)
        resp = time.ctime()
        sock.sendto(resp.encode('ascii'), addr)
    sock.close() # 通信完毕,关闭套接字

if __name__ == '__main__':
    time_server(('', 20000))
```

* `UDP`客户端

```python
from socket import socket, AF_INET, SOCK_DGRAM

s = socket(AF_INET, SOCK_DGRAM) # 创建套接字对象
s.sendto(b'', ('localhost', 20000)) # 连接服务端
content = s.recvfrom(8192) # 发送请求数据
print(content)
s.close() # 通信完毕,关闭套接字
```

##### `TCP`粘包

粘包现象发生的原因分为以下两种：

1) 发送方引起的粘包：

这种情况下引起的粘包是`TCP`协议本身造成的，`TCP`为了提高传输效率，发送方往往要收集到足够多的数据后才发送一个`TCP`段 (超过时间间隔也会发送，时间间隔是很短的)，如果连续几次需要发送的数据都很少 , 通常`TCP`会根据优化算法把这些数据合成一个`TCP`段后一次发送出去，所以几次的数据到接收方时就粘成一包了。

```python
from socket import socket, AF_INET, SOCK_STREAM

s = socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 20000))
s.send(b"I'm ") # 发送方第一次发送
s.send(b"Lyon") # 不超过时间间隔立马发送第二次

data = s.recv(1024)

print(data.decode()) # 收到的是两次粘在一起的数据，打印结果: I'm Lyon
```

2) 接收方引起的粘包

这种情况引起的粘包则是因为接收方不及时接收缓冲区的数据包造成的，比如发送方一次发送了`10`字节的数据，而接收方只接收了2字节，那么剩余的`8`字节的数据将都在缓冲区等待接收，而此时发送方又发送了2字节的数据，过了一会接收方接收了`20`字节(大于剩余`10`字节)，接收完毕，缓冲区剩余的数据就和第二次发送的数据粘成了一个包，产生粘包。

```python
from socket import socket, AF_INET, SOCK_STREAM

s = socket(AF_INET, SOCK_STREAM)
s.connect(('localhost', 20000))

s.send(b"I'm")
data1 = s.recv(1)
print("data1:", data1)
s.send(b"Lyon")
data2 = s.recv(7)
print("data2:", data2)
data3 = s.recv(7)
print("data3:", data3)

# data1: b'I'
# data2: b"'m"
# data3: b'Lyon'
```

粘包是因为接收方不知道消息界限，所以可以创建界限来明确界限。

1) `low`方法

* 服务端

```python
from socket import socket, AF_INET, SOCK_STREAM
import subprocess

def echo_handler(address, client_sock):
    print('Got connection from {}'.format(address))
    while True:
        msg = client_sock.recv(8192)
        if not msg:
            print("Client is disconnected...")
            break
        print('Message:', msg)
        data = subprocess.Popen(msg.decode(), shell=True,
                                stdout=subprocess.PIPE,
                                stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        err = data.stderr.read()
        if err:
            res = err
        else:
            res = data.stdout.read()
        client_sock.send(str(len(res)).encode('utf-8'))
        ready = client_sock.recv(1024)
        if ready == b'OK':
            client_sock.sendall(res)
    client_sock.close()

def echo_server(address, backlog=5):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(address)
    sock.listen(backlog)
    while True:
        print("Waitting for connection...")
        client_sock, client_addr = sock.accept()
        echo_handler(client_addr, client_sock)

if __name__ == '__main__':
    echo_server(('', 20000))
```

* 客户端

```python
from socket import socket, AF_INET, SOCK_STREAM

sock = socket(AF_INET, SOCK_STREAM)
sock.connect(('localhost', 20000))

while True:
    cmd = input("Please input the command:").strip()
    if not cmd:
        print("Can't empty...")
        continue
    elif cmd == 'exit':
        break
    sock.send(cmd.encode('utf-8'))
    length = sock.recv(1024).decode('utf-8')
    sock.send(b'OK')
    recvsize = 0
    data = b''
    while recvsize < int(length):
        recvdata = sock.recv(1024)
        recvsize += len(recvdata)
        data += recvdata
    print(data.decode('utf-8'))
sock.close()
```

2) 制作报头

* 服务端

```python
from socket import socket, AF_INET, SOCK_STREAM
import subprocess
import struct

def echo_handler(address, client_sock):
    print('Got connection from {}'.format(address))
    while True:
        msg = client_sock.recv(8192)
        if not msg:
            print("Client is disconnected...")
            break
        print('Message:', msg)
        data = subprocess.Popen(msg.decode(), shell=True,
                                stdout=subprocess.PIPE,
                                stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        err = data.stderr.read()
        if err:
            res = err
        else:
            res = data.stdout.read()
        client_sock.send(struct.pack('i', len(res)))
        client_sock.sendall(res)
    client_sock.close()

def echo_server(address, backlog=5):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(address)
    sock.listen(backlog)
    while True:
        print("Waitting for connection...")
        client_sock, client_addr = sock.accept()
        echo_handler(client_addr, client_sock)

if __name__ == '__main__':
    echo_server(('', 20000))
```

* 客户端

```python
from socket import socket, AF_INET, SOCK_STREAM
import struct

sock = socket(AF_INET, SOCK_STREAM)
sock.connect(('localhost', 20000))

while True:
    cmd = input("Please input the command:").strip()
    if not cmd:
        print("Can't empty...")
        continue
    elif cmd == 'exit':
        break
    sock.send(cmd.encode('utf-8'))
    res = sock.recv(4)
    length = struct.unpack('i', res)[0]
    recvsize = 0
    data = b''
    while recvsize < length:
        data += sock.recv(1024)
        recvsize += len(data)
    print(data.decode('utf-8'))
sock.close()
```

#### 1.3.9 WSGI接口和HTTP服务

通过`TCP`协议，构建一个最原始的`HTTP`服务器：

```python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('127.0.0.1', 9999))
s.listen(5)

while True:
    conn, addr = s.accept()
    request = conn.recv(1024) 
    response = b'''HTTP/1.x 200 OK
Content-Type: text/html

<html>
    <head>
    <title>hi</title>
    </head>
    <p>hi, python</p>
</html>
'''
    method = request.decode('utf-8').split(' ')[0]
    if method == 'GET':
        conn.sendall(response)
    conn.close()
```

Python Web服务器网关接口（英文：`Python Web Server Gateway Interface`，缩写：`WSGI`)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标。

`WSGI`没有官方的实现, 因为`WSGI`更像一个协议. 只要遵照这些协议,`WSGI`应用(Application)都可以在任何服务器(Server)上运行, 反之亦然,。即实现了`wsgi`接口的应用可以互通，调用。

类似的这种“通道”或者较叫“接口”的还有`CGI`、`FastCGI`...

```python
from wsgiref.simple_server import make_server

# application 由wsgi服务器调用、函数对http请求与响应的封装、使得Python专注与HTML
def application(environ, start_response):
    if environ['REQUEST_METHOD'] == 'GET' and environ['PATH_INFO'] == '/':
        start_response('200 OK', [('Content-Type', 'text/html')]) # 响应
    return [b'<h1>hi, py!</h1>']

httpd = make_server('127.0.0.1', 8000, application) # 启动服务器 | 这个服务器负责与 wsgi 接口的 application 函数对接数据

httpd.serve_forever() # 监听请求
```

这些都是基于wsgi协议实现的Python http 服务器

#### 1.3.10 RPC编程

远程过程调用（英文：`Remote Procedure Call`，缩写：`RPC`）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。

`XML-RPC`实现一个远程方法调用：

* 服务端

```python
from xmlrpc.server import SimpleXMLRPCServer

class KeyValueServer:
    _rpc_methods_ = ['get', 'set', 'delete', 'exists', 'keys']
    def __init__(self, address):
        self._data = {}
        self._serv = SimpleXMLRPCServer(address, allow_none=True)
        for name in self._rpc_methods_:
            self._serv.register_function(getattr(self, name))

    def get(self, name):
        return self._data[name]

    def set(self, name, value):
        self._data[name] = value

    def delete(self, name):
        del self._data[name]

    def exists(self, name):
        return name in self._data

    def keys(self):
        return list(self._data)

    def serve_forever(self):
        self._serv.serve_forever()

if __name__ == '__main__':
    kvserv = KeyValueServer(('', 15000))
    kvserv.serve_forever()
```

* 客户端

```python
>>> from xmlrpc.client import ServerProxy
>>> s = ServerProxy('http://localhost:15000', allow_none=True)
>>> s.set('foo', 'bar')
>>> s.set('spam', [1, 2, 3])
>>> s.keys()
['spam', 'foo']
>>> s.get('foo')
'bar'
>>> s.get('spam')
[1, 2, 3]
>>> s.delete('spam')
>>> s.exists('spam')
False
>>>
```

后续在*消息中间件*等章节再涉及更为深入的`RPC`知识。