## 6.4 中间件-`RPC`

>date: 2019-05-14

![](../assets/images/64.jpg)

### 6.4.1 概述

`RPC`的全称是`Remote Procedure Call`，是一种进程间通信方式。它允许程序调用另一个进程上（通常是共享网络的另一台机器上）的过程或函数，而不用显式编码这个远程调用的细节。

* 原理

在`RPC`框架中主要有三个角色：`Provider`、`Consumer`和`Registry`。

其中：

1. `Server`: 暴露服务的服务提供方；

2. `Client`: 调用远程服务的服务消费方；

3. `Registry`: 服务注册与发现的注册中心。

![`RPC`框架角色](../assets/images/641_01.jpg)

上图是阿里的`Dubbo`框架的一次`RPC`调用过程，在这个过程中，各个角色的调用关系如下：

1. `Container`负责启动，加载，运行服务提供者；

2. `Provider`在启动时，向`Registry`注册自己提供的服务；

3. `Consumer`在启动时，向`Registry`订阅自己所需的服务；

4. `Registry`返回`Provider`地址列表给`Consumer`，如果有变更，注册中心将基于长连接推送变更数据给`Consumer`；

5. `Consumer`从`Provider`地址列表中，基于软负载均衡算法，选一个`Provider`进行调用，如果调用失败，再选另一台调用；

6. `Consumer`和`Provider`，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到`Monitor`。

* `RPC`框架架构

![`RPC`框架架构](../assets/images/641_03.png)

* 一次`RPC`调用的流程

![`RPC`调用的流程](../assets/images/641_02.png)

1. 服务消费方(`Client`)调用以本地调用方式调用服务；

2. `Client Stub`接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

3. `Client Stub`找到服务地址，并将消息发送到服务端；

4. `Server Stub`收到消息后进行解码；

5. `Server Stub`根据解码结果调用本地的服务；

6. 本地服务执行并将结果返回给`Server Stub`；

7. `Server Stub`将返回结果打包成消息并发送至消费方；

8. `Client Stub`接收到消息，并进行解码；

9. 服务消费方得到最终结果。

`RPC`的目标就是要`2~8`这些步骤都封装起来，让调用者对这些细节透明。

### 6.4.2 传输

一般的`RPC`是建立在`TCP`协议上的，相较于`UDP`，`TCP`协议更加可靠。

`RPC`传输的内容存储在`TCP`的`body`中，这个内容包含`header + body`，也经常叫做`payload`。

`TCP`能可靠地把数据在不同的地址空间上搬运。

例如在传统的阻塞 `I/O` 模型中，当有数据过来的时候，操作系统内核把数据从 `I/O` 中读出来存放在 `kernal space`，然后内核就通知 `user space` 可以拷贝走数据，用以腾出空间，让 `TCP` 滑动窗口向前移动，接收更多的数据。

### 6.4.3 `I/O`模型

做一个高性能可扩展的`RPC`，需要能够满足：

1. 服务端尽可能多的处理并发请求；
2. 同时尽可能短的处理完毕。

常见可选择的`I/O`模型介绍：[并发编程](../Python高级编程/并发编程.md#146-io模型)

### 6.4.4 `Schema`和序列化

当`I/O`完成后，数据可以由程序处理，那么如何识别这些二进制的数据，是下一步要做的。序列化和反序列化，是做对象到二进制数据的转换，程序是可以理解对象的，对象一般含有`schema`或者结构，基于这些语义来做特定的业务逻辑处理。

考察一个序列化框架一般会关注以下几点：

1. 编码格式：`human readable`还是`binary`；

2. 契约声明：基于`IDL`(交互式数据语言)，比如`Protocol Buffers/Thrift`，还是自描述的，比如`JSON`、`XML`。另外还需要看是否是强类型的；

3. 语言平台的中立性：是否可以跨各种语言和平台进行开发；

4. 新老契约的兼容性：比如`IDL`加了一个字段，老数据是否还可以反序列化成功；

5. 和压缩算法的契合度：跑`benchmark`和实际应用都会结合各种压缩算法；

6. 性能这是最重要的：序列化、反序列化的时间，序列化后数据的字节大小是考察重点。

序列化方式非常多，常见的有 `Protocol Buffers`，`Avro`，`Thrift`，`XML`，`JSON`，`MessagePack`，`Kyro`，`Hessian`，`Protostuff`，`Java Native Serialize`，`FST`。

### 6.4.5 协议结构

协议结构，`Wire Protocol`或者`Wire Format`。`TCP` 只是二进制流的通道，是 二进制数据的可靠搬用工，它不懂 RPC 里面包装的是什么，而在一个通道上传输`payload`，势必涉及`payload`的识别。

`TCP`是面向字节，不存在消息边界，所以传输的时候可能存在粘包问题。

这时候应用层如何做语义级别的`payload`识别是个问题，只有做好了协议的结构，才能把一整个数据片段做序列化或者反序列化处理。

一般采用的方式有三种：

1. 分隔符

2. 换行符

比如 `memcache` 由客户端发送的命令使用的是文本行`\r\n`做为`payload`的分隔符，组织成一个有意义的`payload`。

3. 固定长度

`RPC`经常采用这种方式，使用`header+payload`的方式。

比如`HTTP`协议是建立在 `TCP` 之上最广泛使用的`RPC`，`HTTP`头中肯定有一个 `body length`告知应用层如何去读懂一个`payload`，做`HTTP`包的识别。

### 6.4.6 可靠性和易用性

* 可靠性

`RPC`框架如何取处理各种因为网络的不可靠导致各种不确定性是很重要的。

例如如何保持长连接心跳？网络闪断怎么办？重连、重传？连接超时？这些都非常的细碎和麻烦，所以说开发好一个稳定的`RPC`框架是一个非常系统和细心的工程。

* 易用性

`RPC`是需要让上层写业务逻辑来实现功能的，如何优雅地启停一个`server`，注入 `endpoint`，客户端怎么连，重试调用，超时控制，同步异步调用等等，都决定了基于`RPC`构建服务，甚至`SOA`的工程效率与生产力高低。