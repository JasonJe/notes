## 6.2 中间件-消息队列

>date: 2019-03-22

![](../assets/images/62.jpg)

### 6.2.1 概述

* 消费者和生产者

生产者是创建消息的一方，这个消息包含了有效载荷(`payload`)和标签(`label`)两部分内容，其中有效载荷就是需要传输的数据，而标签是对有效载荷的描述。

消费者是订阅消息的一方，它只能得到消息的有效载荷，却并不能得到消息的标签，如果发送方的消息不存在于标签中，就要看生产者有无将发送方消息放入有效载荷中了。

* 消息队列

生产者和消费者之间进行通信需要建立一条信道(`channel`)，这个信道不同于`TCP`连接，它是一条认证的`TCP`连接，每次通讯就在这条`TCP`连接上创建信道，这就形成了消息队列。

如果生产者或消费者之间只进行`TCP`连接，对操作系统的`TCP`栈会产生大量的浪费，同时也会很容易达到性能瓶颈。

* 消息队列可解决的问题

传统的进程通信模式会出现因网络等情况发生客户端等待服务端响应，调用超时，耦合度过高而出现的各种问题。

基于消息队列进行进程间的通信，在消息传输过程中代理的消息的存储和转发，能保证消息的传递，对两个进程进行解耦，提供异步通信，生产者和消费者无需连接也能路由等。

![消息队列](../assets/images/621_01.png)

* 消息队列特点

先进先出、发布和订阅、持久化、分布式

### 6.2.2 使用场景

1) 异步处理

非核心流程异步化，提高系统响应性能

2) 应用解耦

系统不是强耦合，消费者可以随意增加，而不需要修改生产者的代码。生产者的成功不依赖消费者；

不强依赖于非本系统的核心流程，对于非核心流程，可以放到消息队列中让消费者去按需消费，而不影响核心主流程。

3) 最终一致性

最终一致性不是消息队列的必备特性，但确实可以依靠消息队列来做最终一致性的事情；

先写消息再操作，确保操作完成后再修改消息状态。定时任务补偿机制实现消息可靠发送接收、业务操作的可靠执行，要注意消息重复与幂等设计；

所有不保证`100%`不丢消息的消息队列，理论上无法实现最终一致性。

4) 广播

生产者只需要关心消息是否送达了队列，至于谁进行订阅，是消费者的事情

5) 流量削峰与流控

当生产者能力大于消费者能力的时候，利用消息队列做一个通用的"漏斗"，在消费者有能力处理的时候，再进行分发。

6) 日志处理

将消息队列用在日志处理中，比如`Kafka`的应用，解决大量日志传输的问题。

7) 消息通讯

消息队列一般都内置了高效的通信机制，因此也可以用于单纯的消息通讯，比如即时通信。

### 6.2.3 消息模型

1) 点对点模型

点对点模型用于生产者和消费者之间点到点的通信。生产者将消息发送到某个名字标识的特定消费者。

特点：每个消息只有一个消费者、生产者和消费者没有时间依赖、由消费者来确认消息接收和处理成功

2) 发布订阅模型

发布订阅模型支持向一个特定的消费主题生产消息，多个消费者订阅这个消费主题。多个消费者可以获得消息，在发布者和订阅者之间存在时间依赖性。

发布者需要建立一个订阅，一共消费者订阅。订阅者必须保持持续的活动状态并接收消息。

特点：每个消息有多个订阅者、客户端只有订阅后才能接收消息、持久订阅和非持久订阅。

持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；

非持久订阅：订阅者为了接受消息，必须一直在线。 当只有一个订阅者时大致等于点对点模式。

### 6.2.4 `AMQP` 和 `RabbitMQ`

#### `AMQP`

`AMQP`(高级消息队列协议)能够像邮箱一样为存储消息，也能进行一对一的通信。但是不同于`IM`(即时通讯)和邮箱，`AMQP`能存储没有固定结构的消息，甚至能直接存储二进制数据，同时能对消息进行一对多的广播。

消息被发布者(`publisher`)发送到交换机，交换机(`exchange`)将收到的消息根据路由规则分发给绑定的队列，最后`AMQP`代理将消息投递给订阅这个队列的消费者，或由消费者按需获取。

![路由转发过程](../assets/images/624_01.png)

发布者(`publisher`)发布消息时可以给消息指定各种消息属性(`message meta-data`)。有些属性有可能会被消息代理(`brokers`)使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。

`AMQP`设计了一个消息确认(`message acknowledgements`)模块，当消息从队列里面投递给消费者后，消费者会通知一下消费代理(`broker`)是否收到消息。

消息在消费代理未收到消费者的确认回执(`acknowledgement`)时候，都不会完全从消息队列中删除。

如果一个消息没有被成功路由，消息会被返回发布者或者丢弃。

如果消息代理执行了延期操作，消息会被放入一个死信队列中，以供发布者去处理。

队列，交换机和绑定统称为`AMQP`实体（`AMQP entities`）。

* 交换机(`exchange`)

交换机在声明的时候附带许多属性，较为常见的是：`Name`、`Durability` (消息代理重启后，交换机是否还存在)、`Auto-delete`(当所有与之绑定的消息队列都完成了对此交换机的使用后即删除)、`Arguments`

交换机可以有两个状态：持久(`durable`)、暂存(`transient`)。

持久化的交换机会在消息代理重启后依旧存在，而暂存的交换机则不会。

```bash
$ rabbitmqctl list_exchanges
Listing exchanges ...
logs      fanout
amq.direct      direct
amq.topic       topic
amq.fanout      fanout
amq.headers     headers
...done.
```

1) 直连交换机(`direct exchange`)

将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键(`routing key`)；

当消息携带同样的路由键发送给交换机时，会将它路由给该队列。

![直连交换机](../assets/images/624_02.png)

直连交换机经常循环分发任务给消费者，所以消息的负载均衡发生在消费者上，而不是队列之间。

2) 扇型交换机(`funout exchange`)

将消息路由绑定到它身上的所有队列，不理会绑定的路由键。

将新进来的消息进行拷贝，并进行广播路由到所有绑定到它的队列。

![扇型交换机](../assets/images/624_03.png)

3) 主题交换机(`topic exchanges`)

通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。即有针对性的分发到消费者。

4) 头交换机(`headers exchange`)

使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。

类似直连交换机，但是头交换机的路由规则建立在头属性上。

* 队列(`queue`)

队列常见的属性：`Name`、`Durable`(消息代理重启后，队列是否依旧存在)、`Exclusive`(只被一个连接`connection`使用，而且当连接关闭后队列即被删除)、`Auto-delete`(当最后一个消费者退订后即被删除)、`Arguments`

* 绑定(`binding`)

交换机将消息路由给队列所需遵循的规则。

* 消息确认

自动确认模式(`automatic acknowledgement model`)：当消息代理(`broker`)将消息发送给应用后立即删除。

显式确认模式(`explicit acknowledgement model`)：发送一个确认回执(`acknowledgement`)后再删除消息。

#### `RabbitMQ`

`RabbitMQ`是实现了高级消息队列协议(`AMQP`)的开源消息代理软件。

* 常用命令

```bash
$ rabbitmq-plugins enable rabbitmq_management # 启动监控管理器
$ rabbitmq-plugins disable rabbitmq_management # 关闭监控管理器
$ rabbitmq-service start # 启动RabbitMQ
$ rabbitmq-service stop # 关闭RabbitMQ
$ rabbitmqctl list_queues # 查看所有的队列
$ rabbitmqctl reset # 清除所有的队列
$ rabbitmqctl stop_app # 关闭应用
$ rabbitmqctl start_app # 启动应用


$ rabbitmqctl add_user username password # 添加用户
$ rabbitmqctl set_user_tags username administrator # 分配角色
$ rabbitmqctl add_vhost  vhost_name # 新增虚拟主机
$ rabbitmqctl set_permissions -p vhost_name username ".*" ".*" ".*" # 将新虚拟主机授权给新用户，后面三个”*”代表用户拥有配置、写、读全部权限
```

* 简单的消息发送

`Server`端(消费者)代码：

```python
>>> import pika
>>>
>>> credentials = pika.PlainCredentials('user', 'password') # 验证信息
>>>
>>> connection = pika.BlockingConnection(pika.ConnectionParameters(
...                                         host = 'localhost',
...                                         port = '5672',
...                                         virtual_host = '/',
...                                         credentials = credentials
...                                     )) # 建立连接
>>>
... channel = connection.channel() # 创建信道
>>>
>>> channel.queue_declare(queue='test') # 声明队列并创建
<METHOD(['channel_number=1', 'frame_type=1', "method=<Queue.DeclareOk(['consumer_count=0', 'message_count=1', 'queue=test'])>"])>
>>>
>>> def callback(ch, method, properties, body): # 定义回调函数，即获取消息，进行对应的消费操作
...     print(" [x] Received %r" % body)
...
>>> channel.basic_consume(callback,
...                       queue='test',
...                       no_ack=True) # 进行对应的消费操作
'ctag1.34e2a3916198456b9220b6ea5ba0367a'
>>>
>>> print(' [*] Waiting for messages. To exit press CTRL+C')
 [*] Waiting for messages. To exit press CTRL+C
>>> channel.start_consuming() # 信道开始阻塞
 [x] Received b'My test.'

```

`Client`端(生产者)代码：

```python
>>> import pika
>>>
>>> credentials = pika.PlainCredentials('user', 'password')
>>>
>>> connection = pika.BlockingConnection(pika.ConnectionParameters(
...                                         host = 'localhost',
...                                         port = '5672',
...                                         virtual_host = '/',
...                                         credentials = credentials
...                                     ))
>>>
... channel = connection.channel()
>>>
>>> channel.queue_declare(queue='test')
<METHOD(['channel_number=1', 'frame_type=1', "method=<Queue.DeclareOk(['consumer_count=0', 'message_count=0', 'queue=test'])>"])>
>>>
>>> channel.basic_publish(exchange='',
...                       routing_key='test',
...                       body='My test.') # 发布消息
True
>>>
>>> print(" [x] Sent 'My test.'")
 [x] Sent 'My test.'
>>> connection.close() # 关闭连接
```

* 工作队列

![工作队列](../assets/images/624_04.png)

`Server`端(消费者)代码：

这里可以运行多个消费者代码以达到队列里的任务共享。

默认情况下，每个消费者都能收到同等数量的消息，这种发送消息的方式叫做轮询(`round-robin`)。

```python
import pika
import time

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

# RabbitMQ不允许你使用不同的参数重新定义一个队列
# durable=True将队列声明为持久化，保证队列在退出或崩溃时候不会消失
channel.queue_declare(queue='test', durable=True) 
print(' [*] Waiting for messages. To exit press CTRL+C')

def callback(ch, method, properties, body):
    print(" [x] Received %r" % (body,))
    time.sleep(1)
    print(" [x] Done")
    ch.basic_ack(delivery_tag = method.delivery_tag)

channel.basic_qos(prefetch_count=1) # prefetch_count=1 保证了在同一时刻，不发送超过1条消息给消费者，知道它已经处理了上一条消息并作出了响应
channel.basic_consume(callback,
                      queue='test',
                      no_ack=False) # 这里将自动确认关闭了，需要做显示的消息确认

channel.start_consuming()
```

`Client`端(生产者)代码：

```python
import pika
import sys

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.queue_declare(queue='test', durable=True)

message = ' '.join(sys.argv[1:]) or "Hello World!"
channel.basic_publish(exchange='',
                      routing_key='test',
                      body=message,
                      properties=pika.BasicProperties(
                         delivery_mode = 2,
                      )) # delivery_mode=2保证了消息也是持久化的

print(" [x] Sent %r" % (message,))
connection.close()
```

* 发布与订阅

![发布与订阅](../assets/images/624_05.png)

`Server`端(消费者)代码：

```python
import pika
import time

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.exchange_declare(exchange='logs', # exchange=''时，指匿名交换机
                         exchange_type='fanout') # exchange_type='fanout'指定使用扇形交换机

result = channel.queue_declare(exclusive=True) # 不给名字参数和使用exclusive=True能是队列与消费者断开连接时候立即删除队列
queue_name = result.method.queue

channel.queue_bind(exchange='logs',
                   queue=queue_name) # 声明绑定，绑定连接交换机和队列

print(' [*] Waiting for logs. To exit press CTRL+C')

def callback(ch, method, properties, body):
    print(" [x] %r" % (body,))

channel.basic_consume(callback,
                      queue=queue_name,
                      no_ack=True)

channel.start_consuming()
```

`Client`端(生产者)代码：

生产者生成的消息，全部订阅了同一交换机的消费者都能收到消息

```python
import pika
import sys

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.exchange_declare(exchange='logs',
                         exchange_type='fanout') # 通过交换机名称进行订阅

message = ' '.join(sys.argv[1:]) or "info: Hello World!"
channel.basic_publish(exchange='logs',
                      routing_key='',
                      body=message)
print(" [x] Sent %r" % (message,))
connection.close()
```

* 路由

![路由](../assets/images/624_06.png)

`Server`端(消费者)代码：

```python
import pika
import sys

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.exchange_declare(exchange='direct_logs',
                         exchange_type='direct')

result = channel.queue_declare(exclusive=True)
queue_name = result.method.queue

severities = sys.argv[1:]
if not severities: # 选择需要接收的类型
    print("Usage: %s [info] [warning] [error]" % (sys.argv[0],), file=sys.stderr)
    sys.exit(1)

for severity in severities:
    channel.queue_bind(exchange='direct_logs',
                       queue=queue_name,
                       routing_key=severity) # routing_key=severity 指定绑定键，即路由键

print(' [*] Waiting for logs. To exit press CTRL+C')

def callback(ch, method, properties, body):
    print(" [x] %r:%r" % (method.routing_key, body,))

channel.basic_consume(callback,
                      queue=queue_name,
                      no_ack=True)

channel.start_consuming()
```

`Client`端(生产者)代码：

```python
import pika
import sys

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.exchange_declare(exchange='direct_logs',
                         exchange_type='direct')

severity = sys.argv[1] if len(sys.argv) > 1 else 'info'
message = ' '.join(sys.argv[2:]) or 'Hello World!'
channel.basic_publish(exchange='direct_logs',
                      routing_key=severity,
                      body=message)
print(" [x] Sent %r:%r" % (severity, message))
connection.close()
```

* 主题交换机

当一个队列的绑定键为`#`的时候，这个队列将会无视消息的路由键，接收所有的消息。

当一个队列的绑定键为`<word>.*`的时候，这个队列将会接收路由键为`<word>.<word>`的消息。

![主题交换机](../assets/images/624_07.png)

`Server`端(消费者)代码：

```python
import pika
import sys

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.exchange_declare(exchange='topic_logs',
                         exchange_type='topic')

result = channel.queue_declare(exclusive=True)
queue_name = result.method.queue

binding_keys = sys.argv[1:]
if not binding_keys:
    print("Usage: %s [binding_key]..." % (sys.argv[0],), file=sys.stderr)
    sys.exit(1)

for binding_key in binding_keys:
    channel.queue_bind(exchange='topic_logs',
                       queue=queue_name,
                       routing_key=binding_key)

print(' [*] Waiting for logs. To exit press CTRL+C')

def callback(ch, method, properties, body):
    print(" [x] %r:%r" % (method.routing_key, body,))

channel.basic_consume(callback,
                      queue=queue_name,
                      no_ack=True)

channel.start_consuming()
```

`Client`端(生产者)代码：

```python
import pika
import sys

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.exchange_declare(exchange='topic_logs',
                         exchange_type='topic')

routing_key = sys.argv[1] if len(sys.argv) > 1 else 'anonymous.info'
message = ' '.join(sys.argv[2:]) or 'Hello World!'
channel.basic_publish(exchange='topic_logs',
                      routing_key=routing_key,
                      body=message)
print(" [x] Sent %r:%r" % (routing_key, message))
connection.close()
```

* 远程方法调用

实现远程方法调用需要将服务端回复的消息加入到一个回调队列中，即客户端在发送请求消息时，同时发送一个回调队列的地址。

`correlation_id`是保证辨识响应属于哪个客户端的一个独一无二的值，通过这个来关联客户端。

![远程方法调用](../assets/images/624_08.png)

`Server`端(消费者)代码：

```python
import pika

credentials = pika.PlainCredentials('user', '!QAZ2wsx3edc')

connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = 'localhost',
                                        port = '5672',
                                        virtual_host = '/',
                                        credentials = credentials
                                    ))
channel = connection.channel()

channel.queue_declare(queue='rpc_queue')

def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

def on_request(ch, method, props, body):
    n = int(body)

    print(" [.] fib(%s)"  % (n,))
    response = fib(n)

    ch.basic_publish(exchange='',
                     routing_key=props.reply_to,
                     properties=pika.BasicProperties(
                             correlation_id = props.correlation_id),
                     body=str(response))
    ch.basic_ack(delivery_tag = method.delivery_tag)

channel.basic_qos(prefetch_count=1)
channel.basic_consume(on_request, queue='rpc_queue')

print(" [x] Awaiting RPC requests")
channel.start_consuming()
```

`Client`端(生产者)代码：

```python
import pika
import uuid

class FibonacciRpcClient(object):
    def __init__(self, user, pwd, host, port, vhost):
        self.credentials = pika.PlainCredentials(user, pwd)

        self.connection = pika.BlockingConnection(pika.ConnectionParameters(
                                        host = host,
                                        port = port,
                                        virtual_host = vhost,
                                        credentials = self.credentials
                                    ))

        self.channel = self.connection.channel()

        result = self.channel.queue_declare(exclusive=True)
        self.callback_queue = result.method.queue # 声明一个回调队列

        self.channel.basic_consume(self.on_response, no_ack=True,
                                   queue=self.callback_queue)

    def on_response(self, ch, method, props, body):
        if self.corr_id == props.correlation_id:
            self.response = body

    def call(self, n):
        self.response = None
        self.corr_id = str(uuid.uuid4())
        self.channel.basic_publish(exchange='',
                                   routing_key='rpc_queue',
                                   properties=pika.BasicProperties(
                                         reply_to = self.callback_queue, # 回复的目标队列，即回调队列
                                         correlation_id = self.corr_id, # 关联标识
                                         ),
                                   body=str(n))
        while self.response is None:
            self.connection.process_data_events()
        return int(self.response)

user = 'user'
pwd = 'password'
host = 'localhost'
port = '5672'
vhost = '/'
fibonacci_rpc = FibonacciRpcClient(user, pwd, host, port, vhost)

print(" [x] Requesting fib(30)")
response = fibonacci_rpc.call(30)
print(" [.] Got %r" % (response,))
```

### 6.2.5 `Kafka`