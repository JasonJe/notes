## 6.3 中间件-缓存

>date: 2019-05-12

![](../assets/images/63.jpg)

### 6.3.1 概述

在高并发的分布式的系统中，缓存是必不可少的一部分。没有缓存对系统的加速和阻挡大量的请求直接落到系统的底层，系统是很难撑住高并发的冲击，所以分布式系统中缓存的设计是很重要的一环。

#### 原理

分布式缓存的出现主要是为了帮助高并发访问时，加快系统数据的读写，相较于传统的数据存储层（例如`MySQL`），缓存一般是缓存在内存中的，其性能比传统的数据库存储更好，响应速度更快，能更好地提升用户体验。

同时缓存也能缓存一些复杂耗时的计算结果，降低后端系统对`CPU`、`I/O`、线程等资源的需求，让系统运行在一个相对资源健康的环境。

但是适用分布式缓存随之而来会出现一些问题，诸如数据一致性问题、代码维护、运维成本等等。

#### 设计

设计缓存的时候，需要思考这些问题：

1. 缓存什么内容：缓存热点数据、静态资源等等

2. 缓存放在什么位置：`CDN`、反向代理、分布式缓存服务、本机

3. 如何缓存：如何设计缓存过期策略、设计缓存同步机制等等

### 6.3.2 缓存的应用

#### `CDN`缓存(`Content Delivery Network` 内容分发网络)

主要缓存静态资源，例如图片，视频。

广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中。

#### 反向代理缓存

反向代理是指在网站服务器机房部署代理服务器，实现负载均衡，数据缓存，安全控制等功能。

反向代理位于应用服务器机房，处理所有对`Web`服务器的请求。反向代理一般缓存静态资源，动态资源转发到应用服务器处理。

如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。

如果没有缓冲则先向`Web`服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向`Web`服务器的请求数，从而降低了`Web`服务器的负载。

常用的缓存应用服务器有`Varnish`，`Ngnix`，`Squid`。

#### 分布式缓存

主要指缓存用户经常访问数据的缓存，数据源为数据库。一般起到热点数据访问和减轻数据库压力的作用。

常用的中间件有`Memcache`，`Redis`。

* `Memcache`

高性能、分布式内存类型的对象缓存系统。在内存中维护一个统一的巨大的`Hash`表，能够存储图像、视频、文件、数据库检索结果等数据。

特性：

1. 使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大2G，如果想缓存更多的数据，可以开辟更多的`Memcache`进程（不同端口）或者使用分布式`Memcache`进行缓存，将数据缓存到不同的物理机或者虚拟机上。

2. 使用`key-value`的方式来存储数据，这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为`O(1)`。

3. 协议简单：基于文本行的协议，直接通过`telnet`在`Memcache`服务器上可进行存取数据操作，简单，方便多种缓存参考此协议。

4. 基于`libevent`高性能通信：`Libevent`是一套利用C开发的程序库，它将`BSD`系统的`kqueue`，`Linux`系统的`epoll`等事件处理功能封装成一个接口，与传统的`select`相比，提高了性能。

5. 内置的内存管理方式：所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过LRU算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务，所有数据会丢失。

6. 分布式：各个`Memcache`服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于`Memcache`客户端。当向`Memcache`集群存入（取出）`key-value`时，`Memcache`客户端程序根据一定的算法选择存入哪台服务器，然后再把`key-value`值存到此服务器中。

- 1) 余数算法

先求得键的整数散列值，再除以服务器台数，根据余数确定存取服务器。

优点：计算简单，高效；

缺点：在`Memcache`服务器增加或减少时，几乎所有的缓存都会失效。

- 2) 散列算法（一致性`Hash`）：

先算出`Memcache`服务器的散列值，并将其分布到`0~2^(32)`的圆上；

然后用同样的方法算出存储数据的键的散列值并映射至圆上；

最后从数据映射到的位置开始顺时针查找，将数据保存到查找到的第一个服务器上。

如果超过`0~2^(32)`，依然找不到服务器，就将数据保存到第一台`Memcache`服务器上。

如果添加了一台`Memcache`服务器，只在圆上增加服务器的逆时针方向的第一台服务器上的键会受到影响。

一致性`Hash`算法：解决了余数算法增加节点命中大幅额度降低的问题，理论上，插入一个实体节点，平均会影响到：`虚拟节点数/2` 的节点数据的命中。

7. 缓存策略：`Memcache`的缓存策略是`LRU`（最近最少使用）到期失效策略。在`Memcache`内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当`Memcache`服务器用完分配的内存时，失效的数据被首先替换，然后是最近未使用的数据。

在`LRU`中，`Memcache`使用的是一种`Lazy Expiration`策略，自己不会监控存入的`key/vlue`对是否过期，而是在获取`key`值时查看记录的时间戳，检查`key/value`对空间是否过期，这样可减轻服务器的负载。

* `Redis`

常用数据类型

1. `String`

应用场景：与`Memcache`的`key-value`存储方式类似。

2. `Hash`

应用场景：以存储一个用户信息对象数据为例，用户`ID`为`key`，用户的相关属性为`field`，属性对应的值为`value`。

`Hash`有`2`种不同实现：

- 1) `Hash`的成员比较少时，`Redis`为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的`HashMap`结构，对应的基础结构为`Zipmap`；

- 2) 当成员数量增大时会自动转成真正的`HashMap`，对应的基础结构为`Hash`。

3. `List`

应用场景：列表数据等都可以用`List`结构来实现。

其实现为一个双向链表，可以支持反向查找和遍历，方便操作。不过带来了部分额外的内存开销，`Redis`内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

4. `Set`

应用场景：类似列表，但其内部能自动进行去重的操作，只保留唯一值。

`Set`的内部实现是一个`value`永远为`null`的`HashMap`，实际就是通过计算`Hash`的方式来快速排重的，这也是`Set`能提供判断一个成员是否在集合内的原因。

5. `Sorted Set`

应用场景：与`Set`类似，而`Sorted Set`可以通过用户额外提供一个优先级(`score`)的参数来为成员排序，并且是插入有序的，即自动排序。

其内部使用`HashMap`和跳跃表(`SkipList`)来保证数据的存储和有序，`HashMap`里放的是成员到`score`的映射，而跳跃表里存放的 是所有的成员，排序依据是`HashMap`里存的`score`，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

* `Memcache`与`Redis`的比较

1. 数据结构：`Memcache`只支持`key-value`存储方式，`Redis`支持更多的数据类型，比如`key-value`，`Hash`，`List`，`Set`，`Zset`；

2. 多线程：`Memcache`支持多线程，`Redis`支持单线程；`CPU`利用方面`Memcache`优于`Redis`；

3. 持久化：`Memcache`不支持持久化，`Redis`支持持久化；

4. 内存利用率：`Memcache`高，`redis`低（采用压缩的情况下比`Memcache`高）；

5. 过期策略：`Memcache`过期后，不删除缓存，会导致下次取数据数据的问题，`Redis`有专门线程，清除缓存数据；

#### 本地缓存

本地缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。

### 6.3.3 缓存架构

![常见缓存架构](../assets/images/633_01.png)

职责划分：

1. `CDN`：存放`HTML`，`CSS`，`JS`等静态资源；

2. 反向代理：动静分离，只缓存用户请求的静态资源；

3. 分布式缓存：缓存数据库中的热点数据；

4. 本地缓存：缓存应用字典等常用数据。

### 6.3.4 数据一致性

1. 先缓存后写数据库。缓存成功，数据库写入失败，导致脏读。解决方法为先写数据库后缓存。

2. 先写数据库后缓存。写数据库成功，缓存失败，导致缓存失效。解决方法为读数据库数据，回写缓存。

3. 缓存异步刷新。数据库操作和缓存操作不在同一操作步骤中。解决方法有异步进行缓存刷新，定时刷新等。

### 6.3.5 缓存高可用

实现方式：分布式进行数据的海量缓存。复制实现缓存数据节点的高可用。

一些特别热点的数据，高并发访问同一份缓存数据，导致缓存服务器压力过大。

解决方案：复制多份缓存副本，把请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。

### 6.3.6 缓存雪崩

缓存失效导致系统性能急剧下降的情况；如高并发业务下并发访问存储系统，更新缓存造成的系统崩溃。

解决方案：对缓存更新操作进行加锁保护，保证只有一个线程在进行缓存更新；后台线程（非业务线程）进行缓存更新，后台线程定时进行，或者业务线程缓存失败后通知后台线程进行缓存更新。

### 6.3.7 缓存穿透

缓存一般是 `Key-Value` 方式存在，当某一个 `Key` 不存在时会查询数据库，假如这个 `Key`一直不存在，则会频繁的请求数据库，对数据库造成访问压力。

主要解决方案：对结果为空的数据也进行缓存，当此 `Key` 有数据后，清理缓存；一定不存在的 `Key`，采用布隆过滤器，建立一个大的 `Bitmap` 中，查询时通过该 `Bitmap` 过滤。
