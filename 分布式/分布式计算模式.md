## 6.4 分布式计算模式

>date: 2019-12-16

![](../assets/images/64.jpg)

### 6.4.1 分而治之计算模式

**分而治之**就是将一个复杂、难以直接解决的大问题，分割成一些规模较小的、可以比较简单的问题或可以直接求解的子问题，这些子问题之间相互独立并且与原问题形式相同，递归地求解这些子问题，然后将子问题的解合并得到原问题的解。

**适合的问题**：

- * 问题规模比较大或复杂，且问题可以分解为几个规模较小的、简单的同类型问题进行求解；

- * 子问题之间相互独立，不包含公共子问题；

- * 子问题的解可以合并得到原问题的解。

**核心步骤**：

- 1) **分解原问题**：将原问题分解为若干个规模较小，相互独立，且与原问题形式相同的子问题；

- 2) **求解子问题**：若子问题的规模较小且容易被解决则直接求解，否则递归地求解各个子问题；

- 3) **合并解**：将各个子问题的解合并为原问题的解。

* **`MapReduce` 模型**

- * 抽象模型

`MapReduce` 分为 `Map` 和 `Reduce` 两个核心阶段，其中 `Map` 对应**分**，即将复杂任务分解为若干个简单的任务；`Reduce` 对应着**合**，即将 `Map` 阶段的结果汇总。

![MapReduce 模型](../assets/images/641_01.png)

- * 工作原理

![MapReduce 工作原理](../assets/images/641_02.png)

- 1) `Master`，也就是 `MRAppMaster`，该模块负责分配任务，协调任务的运行，并为 `Mapper` 分配 `map()` 函数操作、为 `Reducer` 分配 `reduce()` 函数操作；

- 2) `Mapper worker`，负责 `Map` 函数功能，即负责执行子任务。

- 3) `Reducer worker`，负责 `Reduce` 函数功能，即负责汇总各个子任务的结果。

- * 工作流程

![MapReduce 工作流程](../assets/images/641_03.png)

- 1) `step1`：`User Program` 将任务下发到 `MRAppMaster` 中。然后，`MRAppMaster` 执行任务拆分步骤，把 `User Program` 下发的任务划分成 `M` 个子任务（`M` 是用户自定义的数值）；

- 2) `step2`：`MRAppMaster` 分别为 `Mapper` 和 `Reducer` 分配相应的 `Map` 和 `Reduce` 作业。`Map` 和 `Reduce` 作业的数量就是划分后的子任务数量；

- 3) `step3`：被分配了 `Map` 作业的 `Worker`，开始读取子任务的输入数据，并从输入数据中抽取出 `<key, value>` 键值对，每一个键值对都作为参数传递给 `map()` 函数；

- 4) `step4`：`map()` 函数的输出结果存储在环形缓冲区 `kvBuffer` 中，这些 `Map` 结果会被定期写入本地磁盘中，被存储在 `R` 个不同的磁盘区。这里的 `R` 表示 `Reduce` 作业的数量，也是由用户定义的。此外，每个 `Map` 结果的存储位置都会上报给 `MRAppMaster`。

- 5) `step5`：`MRAppMaster` 通知 `Reducer` 它负责的作业在哪一个分区，`Reducer` 远程读取相应的 `Map` 结果，即中间键值对。当 `Reducer` 把它负责的所有中间键值对都读过来后，首先根据键值对的 `key` 值对中间键值对进行排序，将相同 `key` 值的键值对聚集在一起，从而有利于 `Reducer` 对 `Map` 结果进行统计。

- 6) `step6`：`Reducer` 遍历排序后的中间键值对，将具有相同 `key` 值的键值对合并，并将统计结果作为输出文件存入负责的分区中。

整个 `MapReduce` 的工作流程主要可以概括为 `5` 个阶段，即：`Input`（输入）、`Splitting`（拆分）、`Mapping`（映射）、`Reducing`（化简）以及 `Final Result`（输出）。

**特点**：可以进行大规模扩展，适合大型计算机集群；拆分后的任务，可以扩多个计算机执行，并且各个小任务之间不会相互通信。
