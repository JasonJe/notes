## 6.5 分布式通信

>date: 2019-12-22

![](../assets/images/65.jpg)

### 6.5.1 远程调用

**远程调用**相较于本地调用中进程内的函数调用，就是进程间函数的相互调用，是进程间**`IPC`**(`Inter-Process Communication`)的一种方式。

根据进程是否部署在同一台机器上，远程调用又可以分成**本地过程调用(`Local Procedure Call`，`LPC`)**和**远程过程调用(`Remote Procedure Call`， `RPC`)**。

- * **本地过程调用**：指运行在同一台机器上的进程之间互相通信，在多进程操作系统中，运行不同的进程之间可以通过`LPC`进行函数调用；

- * **远程过程调用**：指不同机器中运行的进程之间的相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务一样，去调用远程机器上的服务。

* **远程调用原理**

常见的两种远程调用机制有**远程过程调用`RPC`**和**远程方法调用`RMI`**。

- * **远程过程调用**

`RPC` 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法，去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中 `RPC` 会隐藏具体的通信细节。

调用方进程并不需要知道底层是如何传输的，在调用方和用户眼里，**远程过程调用和调用一次本地服务没什么不同**。

**`RPC` 和本地调用的区别**：

- 1) **调用 `ID` 和函数的映射**

在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。而函数名的本质就是一个函数指针，可以看成函数在内存中的地址。

但在 `RPC` 中，只通过函数名来调用函数是不行的，因为不同进程的地址空间是不一样的。

所以在 `RPC` 中，所有函数必须通过一个调用 `ID` 来做唯一标识。一个机器上运行的进程在做远程过程调用是，必须带上这个调用 `ID`。而进行通信的两台机器都需要维护一个函数与调用 `ID` 的映射表。

当调用方进程需要进行远程调用时候，先查询本地映射表，找到对应函数的映射 `ID`，然后将其传到远程机器上，通过映射表确定需要执行的函数。执行完后返回结果到调用方。

- 2) **序列化**

在本地调用中，不同进程间可以共享内存，因此参数的传递只需压入栈，然后需要使用时，出栈即可。

而 `RPC` 需要使用网络传输来进行参数的传递，网络传输的内容是**二进制流**，无法直接传输参数的类型。

这时候就需要调用方和被调用方之间协调一个参数协议，双方基于这个协议将参数转成二进制流或将二进制流转回相应的参数格式。这个过程就是**序列化**和**反序列化**。

- 3) **网络传输协议**

`RPC` 参数基于网络进行传输的，如果想要序列化后的数据能在网络中高效且顺利地传输，就需要相应的网络协议来保障。

同时在一个系统中，如果服务提供方和服务调用方越来越多的时候，服务间的调用关系就会愈加复杂。假设服务提供方有 `n` 个， 服务调用方有 `m` 个，则调用关系可达 `n*m`，这会导致系统的通信量很大。

这时候就出现了**服务注册中心**，对服务提供方提供的服务信息进行存储和管理，对服务调用方提供服务地址和相关的服务信息等。

- * **远程方法调用**

`RMI` 是一个基于 `Java` 环境的应用编程接口，能够让本地 `Java` 虚拟机上运行的对象，像调用本地对象一样调用远程 `Java` 虚拟机上的对象。

`RMI` 可以说是 `RPC` 的一种具体形式，其原理与 `RPC` 基本一致，唯一不同的是 `RMI` 是**基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 `RPC` 实现**。

`RMI` 通过对象作为远程接口来进行远程方法的调用，返回的结果也是对象形式，可以是 `Java` 对象类型，也可以是基本数据类型。

### 6.5.2 发布订阅

**发布订阅**中，**生产者**负责产生数据放到**消息中心**，**消费者**向消息中心**订阅**需要的消息，当发布者推送数据到消息中心后，消息中心根据消费者订阅情况将相关数据推送给对应的订阅者。

* **发布订阅工作原理**

- * **点对点**

生产者将消息发送到消息中心，然后消费者从消息中心取出对应的消息进行消费。消息被消费后，消息中心**不再存储该消息**，因此其他消费者无法再消费该消息。

即**点对点模式**虽然支持多个消费者，但**一个消息只能被一个消费者消费，不允许重复消费**。

- * **发布订阅**

生产者可以发送消息到消息中心，而消息中心通常以主题(`Topic`)进行划分，每条消息都会有相应的主题，消息会被存储到自己所属的主题中，订阅该主题的所有消费者均可获得该消息进行消费。

与点对点模式相比，**发布订阅模式中一个消息可以被多个消费者进行消费，这也是和点对点模式的本质区别**。

* **发布订阅模式的关键特征**

- * **系统解耦，易于维护**：

发布者只负责消息的发布，不需要知道订阅者的数量，也不需要知道订阅者获取消息的用途，而订阅者也不需要知道发布者什么时候会发布消息。

发布者和订阅者互相独立，进而实现了系统解耦，每个部分可以单独维护，减少了因为生产者和消费者的耦合引入的一些相互影响，降低了维护的复杂度。

- * **异步执行，避免高负载**：

发布者发布消息到消息中心，当消息超过消息中心可以存储的容量后，消息中心会丢弃掉超出的消息，这样系统就不会因为消息数量多而导致系统故障。

### 6.5.3 消息队列

**消息队列**就是将消息或数据放到一个队列里，服务如果需要使用消息或数据，就去队列里面取。

消息队列是**基于队列实现**的，**存储具有特定格式的消息数据**，比如定义一个包含消息类型、标志消息唯一性的 `ID`、消息内容的一个结构体作为消息数据的特定格式。

消息以特定格式放入这个队列的尾部后可以直接返回，并不需要系统马上处理，之后会有其他进程从队列头部开始读取消息，按照消息放入的顺序逐一处理。

* **消息队列原理**

消息队列模式也是包括 `3` 个核心部分：

- * **生产者**：生产者产生消息或数据，并将消息或数据插入到消息队列中。

- * **消息队列**：一种具有先进先出特点的数据结构，用于存储消息。

- * **消费者**：从消息队列中获取消息或数据，进行相关处理。

具体流程是，生产者将发送的消息插入消息队列，也就是入队，之后会有一个消费者从消息队列中逐次取出消息进行处理，完成出队。在分布式系统中，上游应用可以不用等待下游应用处理是否完成，只需关系消息队列中年是否有数据即可，这样可以提高响应速度，以及实现组件间的解耦。

* **与发布订阅模式对比**

**数据结构**：

- * 发布订阅模式采用了消息中心，消息队列模式采用了消息队列中心，它们均用来存储生产者发布的数据，并均有主题、`Broker` 等概念；

- * 消息队列模式中采用了具有先进先出特征的队列结构进行存储，发布订阅采用了 `map` 或数组等方式存储。

**解耦方式**：

- * **消息队列模式**中，生产者发布数据到消息队列中心，消息队列中心存储数据，等待消费者按需获取数据。生产者和消费者不直接通信，实现了生产者和消费者的解耦。对于消息队列模式，消息队列中心**无需提前获取消费者信息**，因此对消费者比较灵活，适合消费者为临时用户的场景。

- * **发布订阅模式**中，消费者需要提前向消息中心订阅需要的数据，待生产者发布数据到消息中心后，消息中心根据订阅者订阅信息将数据主动推送给消费者，实现了消费者和生产者的解耦。发布订阅模式，需要消费者提前向消息中心订阅消息，也就是说消息中心需要提前获取消费者信息，比较适合消费者为长驻进程或服务的场景。