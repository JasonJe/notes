## 7.3 Numpy

### 7.3.1 多维数组对象

* 创建数组

```python
>>> import numpy as np
>>> data = np.array([[1, 2], [3, 4]]) # 创建 ndarry 对象
>>> data
array([[1, 2],
       [3, 4]])
>>> data * 10
array([[10, 20],
       [30, 40]])
>>> data + data
array([[2, 4],
       [6, 8]])
>>> data.shape # 获取形状参数
(2, 2)
>>> data.ndim # 获取维数
2
>>> data.dtype # 获取类型
dtype('int32')
>>>
>>> np.zeros((3, 6)) # 新建一个 3 * 6 ，元素值为 0 的数组
array([[0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.]])
>>>
>>> np.empty((2, 3, 2)) # 新建一个指定形状的空数组，元素为随机值，并未初始化
array([[[6.95169907e-310, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000]],

       [[0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000]]])
>>> np.empty_like(np.zeros((2, 10)))
array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])
>>>
>>> np.arange(10) # 类似 range 函数生成一个数组
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> 
>>> np.asarray([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])
>>>
>>> np.ones((2, 3)) # 生成一个 2 * 3,元素值为 1 的数组
array([[1., 1., 1.],
       [1., 1., 1.]])
>>> np.ones_like(np.zeros((2, 10)))
array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])
>>>
>>> np.eye(5) # 创建一个对角线为 1 ，指定大小的方阵
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
>>> np.identity(5)
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
>>>
```

* 数据类型

```python
>>> arr1 = np.array([1, 2, 3], dtype = np.float64)
>>> arr2 = np.array([1, 2, 3], dtype = np.int32)
>>> arr1
array([1., 2., 3.])
>>> arr2
array([1, 2, 3])
>>> arr1.dtype
dtype('float64')
>>> arr2.dtype
dtype('int32')
>>>
>>> arr3 = arr2.astype(np.float64) # 数据类型转换
>>> arr3.dtype
dtype('float64')
>>>
>>> arr4 = np.array(['1', '2', '3'])
>>> arr4
array(['1', '2', '3'], dtype='<U1')
>>> arr4 = arr4.astype(np.float64) # 针对字符串类型进行转换
>>> arr4
array([1., 2., 3.])
>>> arr4.dtype
dtype('float64')
```

|类型|说明|类型代码|
|:--:|:--:|:--:|
|`int8, uint8`|有符号和无符号的`8`(`1`个字节)位整型|`i1, u1`|
|`int16, uint16`|有符号和无符号的`16`(`2`个字节)位整型|`i2, u2`|
|`int32, uint32`|有符号和无符号的`32`(`4`个字节)位整型|`i4, u4`|
|`int64, uint64`|有符号和无符号的`64`(`8`个字节)位整型|`i8, u8`|
|`float16`|半精度浮点数|`f2`|
|`float32`|标准的单精度浮点数，兼容`C`的`float`|`f4, f`|
|`float64`|标准的双精度浮点数，兼容`C`的`double`和`Python`的`float`|`f8, d`|
|`float128`|扩展精度浮点数|`f16, g`|
|`complex64, complex128, complex256`|分别用两个`32`, `64`, `128`位浮点数表示的复数|`c32`|
|`bool`|存储`True`和`False`的布尔型|`?`|
|`object`|`Python`对象类型|`O`|
|`string_`|固定长度的字符串类型，指定长度，使用`S10`|`S`|
|`unicode_`|固定长度的`unicode`类型，指定长度，使用`U10`|`U`|

* 索引

```python
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr[5:8]
array([5, 6, 7])
>>> arr[5:8] = 0
>>> arr
array([0, 1, 2, 3, 4, 0, 0, 0, 8, 9])
>>> arr_slice = arr[5:8] # 与 list 类型的切片一致
>>> arr_slice
array([0, 0, 0])
>>> arr_slice[:] = 1
>>> arr_slice
array([1, 1, 1])
>>>
>>> arr_copy = arr
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9]) # 广播导致 5:8 位置与arr_slice 相同，即 arr_copy[5:8], arr_slice, arr[5:8]指向的内存地址相同
>>> arr[5:8] = np.arange(5, 8, 1)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr_copy
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>
>>> arr[5:8] = 1
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9])
>>>
>>> arr_copy = arr.copy() # 复制一个arr的副本
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9])
>>> arr[5:8] = np.arange(5, 8, 1)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9]) # 两边值不同了
>>>
>>> arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> arr2d # 二维的数组对象
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[2] # 维度为 1 的第3个元素
array([7, 8, 9])
>>> arr2d[2][1] # 第3个数组的第2个元素
8
>>> arr2d[2, 1]
8
>>> arr2d[:2, :1] # 前2行的第1列元素
array([[1],
       [4]])
>>> arr2d[:2, 1:]
array([[2, 3],
       [5, 6]])
>>>
>>> names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')
>>> names == 'Bob'
array([ True, False, False,  True, False, False, False]) # 返回一个布尔型的索引数组
>>>
>>> data = np.random.randn(7, 4) # 生成 7 行分别对应上述名字的随机数组
>>> data
array([[-0.21253088, -0.67569384, -0.12449345, -1.46312685],
       [-1.45099238,  1.30948808,  1.15083724, -0.84027627],
       [-1.88224688, -2.06625679,  0.0819284 ,  1.58296903],
       [ 0.85397823,  1.18922016,  2.65625648, -0.20259332],
       [ 0.16501675,  0.38877484, -0.86927687,  0.39259078],
       [-0.0997616 ,  0.51897847, -1.98435902, -0.81945642],
       [ 0.42575796,  1.19232035,  1.00591513,  0.33078291]])
>>> data[names == 'Bob'] # 找出索引数组为 True 的行
array([[-0.21253088, -0.67569384, -0.12449345, -1.46312685],
       [ 0.85397823,  1.18922016,  2.65625648, -0.20259332]])
>>> data[names == 'Bob', -2:] # 对 True 行进行切片
array([[-0.12449345, -1.46312685],
       [ 2.65625648, -0.20259332]])
>>> data[names == 'Bob', 3]
array([-1.46312685, -0.20259332])
>>> data[(names == 'Bob') | (names == 'Will')] # 可以进行逻辑运算，实现多个布尔组合
array([[-0.21253088, -0.67569384, -0.12449345, -1.46312685],
       [-1.88224688, -2.06625679,  0.0819284 ,  1.58296903],
       [ 0.85397823,  1.18922016,  2.65625648, -0.20259332],
       [ 0.16501675,  0.38877484, -0.86927687,  0.39259078]])
>>>
>>> data[data < 0] # 找出 data 中值符合条件的元素
array([-0.21253088, -0.67569384, -0.12449345, -1.46312685, -1.45099238,
       -0.84027627, -1.88224688, -2.06625679, -0.20259332, -0.86927687,
       -0.0997616 , -1.98435902, -0.81945642])
>>> data[data < 0] = 0
>>> data
array([[0.        , 0.        , 0.        , 0.        ],
       [0.        , 1.30948808, 1.15083724, 0.        ],
       [0.        , 0.        , 0.0819284 , 1.58296903],
       [0.85397823, 1.18922016, 2.65625648, 0.        ],
       [0.16501675, 0.38877484, 0.        , 0.39259078],
       [0.        , 0.51897847, 0.        , 0.        ],
       [0.42575796, 1.19232035, 1.00591513, 0.33078291]])
>>>
>>> data = np.random.randn(7, 4)
>>> data
array([[ 1.37280748,  0.68587928,  1.09034385,  1.28323835],
       [ 0.18645795,  1.16668298, -0.2295682 ,  0.74859424],
       [ 1.09552118, -1.5762106 , -0.24960003,  0.29628363],
       [ 0.19543801, -0.98002096, -0.26883307,  0.73384208],
       [ 1.87575286,  0.24360039,  0.15442605, -0.11923454],
       [ 1.11632447, -0.3673819 , -0.93741906, -0.31821267],
       [ 0.69106618, -1.1660485 ,  0.64240978, -0.00485668]])
>>> data[[4, 3, 2, 1]] # 生成按指定索引顺序的新数组
array([[ 1.87575286,  0.24360039,  0.15442605, -0.11923454],
       [ 0.19543801, -0.98002096, -0.26883307,  0.73384208],
       [ 1.09552118, -1.5762106 , -0.24960003,  0.29628363],
       [ 0.18645795,  1.16668298, -0.2295682 ,  0.74859424]])
>>> data[[-1, -2, -3]]
array([[ 0.69106618, -1.1660485 ,  0.64240978, -0.00485668],
       [ 1.11632447, -0.3673819 , -0.93741906, -0.31821267],
       [ 1.87575286,  0.24360039,  0.15442605, -0.11923454]])
>>> data[[3, 2, 1, 0], [-1, -2, -3, -4]] 
array([ 0.73384208, -0.24960003,  1.16668298,  1.37280748])
>>> # 下面两种索引方式小朵一样
>>> data[np.ix_([3, 2, 1, 0], [-1, -2, -3, -4])] # 索引器实现
array([[ 0.73384208, -0.26883307, -0.98002096,  0.19543801],
       [ 0.29628363, -0.24960003, -1.5762106 ,  1.09552118],
       [ 0.74859424, -0.2295682 ,  1.16668298,  0.18645795],
       [ 1.28323835,  1.09034385,  0.68587928,  1.37280748]])
>>> data[[3, 2, 1, 0]][:, [-1, -2, -3, -4]] # 切片实现
array([[ 0.73384208, -0.26883307, -0.98002096,  0.19543801],
       [ 0.29628363, -0.24960003, -1.5762106 ,  1.09552118],
       [ 0.74859424, -0.2295682 ,  1.16668298,  0.18645795],
       [ 1.28323835,  1.09034385,  0.68587928,  1.37280748]])
>>>
>>> data.T # 转置
array([[ 1.37280748,  0.18645795,  1.09552118,  0.19543801,  1.87575286,
         1.11632447,  0.69106618],
       [ 0.68587928,  1.16668298, -1.5762106 , -0.98002096,  0.24360039,
        -0.3673819 , -1.1660485 ],
       [ 1.09034385, -0.2295682 , -0.24960003, -0.26883307,  0.15442605,
        -0.93741906,  0.64240978],
       [ 1.28323835,  0.74859424,  0.29628363,  0.73384208, -0.11923454,
        -0.31821267, -0.00485668]])
>>> np.dot(data.T, data) # 计算内积
array([[ 8.3999312 , -1.51818788,  0.81519398,  1.78698675],
       [-1.51818788,  6.83044022,  0.76982328,  0.66085588],
       [ 0.81519398,  0.76982328,  2.69141487,  1.2328499 ],
       [ 1.78698675,  0.66085588,  1.2328499 ,  2.94890194]])
>>>
>>> arr = np.arange(16).reshape((2, 2, 4)) # 生成一个 2 * 2 * 4的三维数组
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 0, 2)) # arr[i][j][k] = arr[j][i][k]
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
>>> arr.swapaxes(0, 1) # 交换第一维度索引个第二维度索引，原理同上 arr[i][j][k] = arr[j][i][k]
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
```


### 7.3.2 通用函数

### 7.3.3 线性代数

### 7.3.4 `IO`操作