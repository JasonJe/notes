## 7.3 Numpy

### 7.3.1 多维数组对象

* 创建数组

```python
>>> import numpy as np
>>> data = np.array([[1, 2], [3, 4]]) # 创建 ndarry 对象
>>> data
array([[1, 2],
       [3, 4]])
>>> data * 10
array([[10, 20],
       [30, 40]])
>>> data + data
array([[2, 4],
       [6, 8]])
>>> data.shape # 获取形状参数
(2, 2)
>>> data.ndim # 获取维数
2
>>> data.dtype # 获取类型
dtype('int32')
>>>
>>> np.zeros((3, 6)) # 新建一个 3 * 6 ，元素值为 0 的数组
array([[0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.]])
>>>
>>> np.empty((2, 3, 2)) # 新建一个指定形状的空数组，元素为随机值，并未初始化
array([[[6.95169907e-310, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000]],

       [[0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000]]])
>>> np.empty_like(np.zeros((2, 10)))
array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])
>>>
>>> np.arange(10) # 类似 range 函数生成一个数组
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> 
>>> np.asarray([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])
>>>
>>> np.ones((2, 3)) # 生成一个 2 * 3,元素值为 1 的数组
array([[1., 1., 1.],
       [1., 1., 1.]])
>>> np.ones_like(np.zeros((2, 10)))
array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])
>>>
>>> np.eye(5) # 创建一个对角线为 1 ，指定大小的方阵
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
>>> np.identity(5)
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
>>>
```

* 数据类型

```python
>>> arr1 = np.array([1, 2, 3], dtype = np.float64)
>>> arr2 = np.array([1, 2, 3], dtype = np.int32)
>>> arr1
array([1., 2., 3.])
>>> arr2
array([1, 2, 3])
>>> arr1.dtype
dtype('float64')
>>> arr2.dtype
dtype('int32')
>>>
>>> arr3 = arr2.astype(np.float64) # 数据类型转换
>>> arr3.dtype
dtype('float64')
>>>
>>> arr4 = np.array(['1', '2', '3'])
>>> arr4
array(['1', '2', '3'], dtype='<U1')
>>> arr4 = arr4.astype(np.float64) # 针对字符串类型进行转换
>>> arr4
array([1., 2., 3.])
>>> arr4.dtype
dtype('float64')
```

|类型|说明|类型代码|
|:--:|:--:|:--:|
|`int8, uint8`|有符号和无符号的`8`(`1`个字节)位整型|`i1, u1`|
|`int16, uint16`|有符号和无符号的`16`(`2`个字节)位整型|`i2, u2`|
|`int32, uint32`|有符号和无符号的`32`(`4`个字节)位整型|`i4, u4`|
|`int64, uint64`|有符号和无符号的`64`(`8`个字节)位整型|`i8, u8`|
|`float16`|半精度浮点数|`f2`|
|`float32`|标准的单精度浮点数，兼容`C`的`float`|`f4, f`|
|`float64`|标准的双精度浮点数，兼容`C`的`double`和`Python`的`float`|`f8, d`|
|`float128`|扩展精度浮点数|`f16, g`|
|`complex64, complex128, complex256`|分别用两个`32`, `64`, `128`位浮点数表示的复数|`c32`|
|`bool`|存储`True`和`False`的布尔型|`?`|
|`object`|`Python`对象类型|`O`|
|`string_`|固定长度的字符串类型，指定长度，使用`S10`|`S`|
|`unicode_`|固定长度的`unicode`类型，指定长度，使用`U10`|`U`|

* 索引

```python
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr[5:8]
array([5, 6, 7])
>>> arr[5:8] = 0
>>> arr
array([0, 1, 2, 3, 4, 0, 0, 0, 8, 9])
>>> arr_slice = arr[5:8] # 与 list 类型的切片一致
>>> arr_slice
array([0, 0, 0])
>>> arr_slice[:] = 1
>>> arr_slice
array([1, 1, 1])
>>>
>>> arr_copy = arr
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9]) # 广播导致 5:8 位置与arr_slice 相同，即 arr_copy[5:8], arr_slice, arr[5:8]指向的内存地址相同
>>> arr[5:8] = np.arange(5, 8, 1)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr_copy
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>>
>>> arr[5:8] = 1
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9])
>>>
>>> arr_copy = arr.copy() # 复制一个arr的副本
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9])
>>> arr[5:8] = np.arange(5, 8, 1)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> arr_copy
array([0, 1, 2, 3, 4, 1, 1, 1, 8, 9]) # 两边值不同了
>>>
>>> arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> arr2d # 二维的数组对象
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
>>> arr2d[2] # 维度为 1 的第3个元素
array([7, 8, 9])
>>> arr2d[2][1] # 第3个数组的第2个元素
8
>>> arr2d[2, 1]
8
>>> arr2d[:2, :1] # 前2行的第1列元素
array([[1],
       [4]])
>>> arr2d[:2, 1:]
array([[2, 3],
       [5, 6]])
>>>
>>> names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
>>> names
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')
>>> names == 'Bob'
array([ True, False, False,  True, False, False, False]) # 返回一个布尔型的索引数组
>>>
>>> data = np.random.randn(7, 4) # 生成 7 行分别对应上述名字的随机数组
>>> data
array([[-0.21253088, -0.67569384, -0.12449345, -1.46312685],
       [-1.45099238,  1.30948808,  1.15083724, -0.84027627],
       [-1.88224688, -2.06625679,  0.0819284 ,  1.58296903],
       [ 0.85397823,  1.18922016,  2.65625648, -0.20259332],
       [ 0.16501675,  0.38877484, -0.86927687,  0.39259078],
       [-0.0997616 ,  0.51897847, -1.98435902, -0.81945642],
       [ 0.42575796,  1.19232035,  1.00591513,  0.33078291]])
>>> data[names == 'Bob'] # 找出索引数组为 True 的行
array([[-0.21253088, -0.67569384, -0.12449345, -1.46312685],
       [ 0.85397823,  1.18922016,  2.65625648, -0.20259332]])
>>> data[names == 'Bob', -2:] # 对 True 行进行切片
array([[-0.12449345, -1.46312685],
       [ 2.65625648, -0.20259332]])
>>> data[names == 'Bob', 3]
array([-1.46312685, -0.20259332])
>>> data[(names == 'Bob') | (names == 'Will')] # 可以进行逻辑运算，实现多个布尔组合
array([[-0.21253088, -0.67569384, -0.12449345, -1.46312685],
       [-1.88224688, -2.06625679,  0.0819284 ,  1.58296903],
       [ 0.85397823,  1.18922016,  2.65625648, -0.20259332],
       [ 0.16501675,  0.38877484, -0.86927687,  0.39259078]])
>>>
>>> data[data < 0] # 找出 data 中值符合条件的元素
array([-0.21253088, -0.67569384, -0.12449345, -1.46312685, -1.45099238,
       -0.84027627, -1.88224688, -2.06625679, -0.20259332, -0.86927687,
       -0.0997616 , -1.98435902, -0.81945642])
>>> data[data < 0] = 0
>>> data
array([[0.        , 0.        , 0.        , 0.        ],
       [0.        , 1.30948808, 1.15083724, 0.        ],
       [0.        , 0.        , 0.0819284 , 1.58296903],
       [0.85397823, 1.18922016, 2.65625648, 0.        ],
       [0.16501675, 0.38877484, 0.        , 0.39259078],
       [0.        , 0.51897847, 0.        , 0.        ],
       [0.42575796, 1.19232035, 1.00591513, 0.33078291]])
>>>
>>> data = np.random.randn(7, 4)
>>> data
array([[ 1.37280748,  0.68587928,  1.09034385,  1.28323835],
       [ 0.18645795,  1.16668298, -0.2295682 ,  0.74859424],
       [ 1.09552118, -1.5762106 , -0.24960003,  0.29628363],
       [ 0.19543801, -0.98002096, -0.26883307,  0.73384208],
       [ 1.87575286,  0.24360039,  0.15442605, -0.11923454],
       [ 1.11632447, -0.3673819 , -0.93741906, -0.31821267],
       [ 0.69106618, -1.1660485 ,  0.64240978, -0.00485668]])
>>> data[[4, 3, 2, 1]] # 生成按指定索引顺序的新数组
array([[ 1.87575286,  0.24360039,  0.15442605, -0.11923454],
       [ 0.19543801, -0.98002096, -0.26883307,  0.73384208],
       [ 1.09552118, -1.5762106 , -0.24960003,  0.29628363],
       [ 0.18645795,  1.16668298, -0.2295682 ,  0.74859424]])
>>> data[[-1, -2, -3]]
array([[ 0.69106618, -1.1660485 ,  0.64240978, -0.00485668],
       [ 1.11632447, -0.3673819 , -0.93741906, -0.31821267],
       [ 1.87575286,  0.24360039,  0.15442605, -0.11923454]])
>>> data[[3, 2, 1, 0], [-1, -2, -3, -4]] 
array([ 0.73384208, -0.24960003,  1.16668298,  1.37280748])
>>> # 下面两种索引方式小朵一样
>>> data[np.ix_([3, 2, 1, 0], [-1, -2, -3, -4])] # 索引器实现
array([[ 0.73384208, -0.26883307, -0.98002096,  0.19543801],
       [ 0.29628363, -0.24960003, -1.5762106 ,  1.09552118],
       [ 0.74859424, -0.2295682 ,  1.16668298,  0.18645795],
       [ 1.28323835,  1.09034385,  0.68587928,  1.37280748]])
>>> data[[3, 2, 1, 0]][:, [-1, -2, -3, -4]] # 切片实现
array([[ 0.73384208, -0.26883307, -0.98002096,  0.19543801],
       [ 0.29628363, -0.24960003, -1.5762106 ,  1.09552118],
       [ 0.74859424, -0.2295682 ,  1.16668298,  0.18645795],
       [ 1.28323835,  1.09034385,  0.68587928,  1.37280748]])
>>>
>>> data.T # 转置
array([[ 1.37280748,  0.18645795,  1.09552118,  0.19543801,  1.87575286,
         1.11632447,  0.69106618],
       [ 0.68587928,  1.16668298, -1.5762106 , -0.98002096,  0.24360039,
        -0.3673819 , -1.1660485 ],
       [ 1.09034385, -0.2295682 , -0.24960003, -0.26883307,  0.15442605,
        -0.93741906,  0.64240978],
       [ 1.28323835,  0.74859424,  0.29628363,  0.73384208, -0.11923454,
        -0.31821267, -0.00485668]])
>>> np.dot(data.T, data) # 计算内积
array([[ 8.3999312 , -1.51818788,  0.81519398,  1.78698675],
       [-1.51818788,  6.83044022,  0.76982328,  0.66085588],
       [ 0.81519398,  0.76982328,  2.69141487,  1.2328499 ],
       [ 1.78698675,  0.66085588,  1.2328499 ,  2.94890194]])
>>>
>>> arr = np.arange(16).reshape((2, 2, 4)) # 生成一个 2 * 2 * 4的三维数组
>>> arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
>>> arr.transpose((1, 0, 2)) # arr[i][j][k] = arr[j][i][k]
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
>>> arr.swapaxes(0, 1) # 交换第一维度索引个第二维度索引，原理同上 arr[i][j][k] = arr[j][i][k]
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],

       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
```


### 7.3.2 通用函数

* 一元通用函数

```python
>>> import numpy as np
>>>
>>> arr = np.random.randn(8) # 生成随机数
>>> arr
array([-0.01157091,  0.75124449,  1.64992541,  1.23205284,  0.03958831, 0.49845519,  0.46732873, -0.5536986 ])
>>> np.abs(arr) # 计算绝对值
array([0.01157091, 0.75124449, 1.64992541, 1.23205284, 0.03958831, 0.49845519, 0.46732873, 0.5536986 ])
>>> np.fabs(arr) # 对于非复数，这个方法能更快地计算绝对值
array([0.01157091, 0.75124449, 1.64992541, 1.23205284, 0.03958831, 0.49845519, 0.46732873, 0.5536986 ])
>>>
>>> np.sqrt(arr) # 计算平方根，该例子中存在负数，所以报了警告
__main__:1: RuntimeWarning: invalid value encountered in sqrt
array([       nan, 0.86674361, 1.28449422, 1.10997876, 0.1989681 , 0.70601359, 0.68361446,        nan])
>>> np.square(arr) # 计算平方
array([1.33886020e-04, 5.64368283e-01, 2.72225385e+00, 1.51795421e+00, 1.56723400e-03, 2.48457574e-01, 2.18396144e-01, 3.06582136e-01])
>>>
>>> np.exp(arr) # 计算指数 e^x
array([0.98849577, 2.11963624, 5.20659144, 3.42826   , 1.04038237,  1.64617627, 1.59572588, 0.57481985])
>>>
>>> np.log(arr) # 自然对数，即 ln(x)
__main__:1: RuntimeWarning: invalid value encountered in log
array([        nan, -0.28602413,  0.50073008,  0.20868176, -3.2292215 , -0.69624159, -0.76072235,         nan])
>>> np.log1p(arr) # 即 ln(x + 1)
array([-0.01163838,  0.56032667,  0.97453149,  0.80292172,  0.03882478, 0.4044347 ,  0.38344356, -0.80676076])
>>> np.log10(arr) # 以 10 为底的对数
__main__:1: RuntimeWarning: invalid value encountered in log10
array([        nan, -0.1242187 ,  0.21746431,  0.09062934, -1.40243308,  -0.30237388, -0.33037752,         nan])
>>> np.log2(arr) # 以 2 为底的对数
__main__:1: RuntimeWarning: invalid value encountered in log2
array([        nan, -0.41264559,  0.7224008 ,  0.30106413, -4.65878184, -1.00446429, -1.09749036,         nan])
>>>
>>> np.sign(arr) # 返回各元素正负号
array([-1.,  1.,  1.,  1.,  1.,  1.,  1., -1.])
>>> np.ceil(arr) # 向上取整
array([-0.,  1.,  2.,  2.,  1.,  1.,  1., -0.])
>>> np.floor(arr) # 向下取整
array([-1.,  0.,  1.,  1.,  0.,  0.,  0., -1.])
>>> np.rint(arr) # 四舍五入取整
array([-0.,  1.,  2.,  1.,  0.,  0.,  0., -1.])
>>> np.modf(arr) # 按照小数、整数两部分分别返回
(array([-0.01157091,  0.75124449,  0.64992541,  0.23205284,  0.03958831, 0.49845519,  0.46732873, -0.5536986 ]), array([-0.,  0.,  1.,  1.,  0.,  0.,  0., -0.]))
>>>
>>> np.isnan(arr) # 返回一个判断元素是否为 NaN 的布尔型数组
array([False, False, False, False, False, False, False, False])
>>> np.isnan(np.sqrt(arr))
array([ True, False, False, False, False, False, False,  True])
>>> np.isfinite(arr) # 返回一个判断元素是否有穷的布尔型数组
array([ True,  True,  True,  True,  True,  True,  True,  True])
>>> np.isfinite(np.sqrt(arr))
array([False,  True,  True,  True,  True,  True,  True, False])
>>> np.isinf(arr) # 返回一个判断元素是否无穷的布尔型数组
array([False, False, False, False, False, False, False, False])
>>>
>>> np.cos(arr) # 计算元素余弦值，值为弧度
array([ 0.99993306,  0.73084001, -0.07904653,  0.33230224,  0.99921649, 0.87832214,  0.89277489,  0.85058549])
>>> np.cosh(arr) # 计算双曲余弦值
array([1.00006694, 1.29570765, 2.69932783, 1.85997658, 1.00078372, 1.12682232, 1.11119997, 1.15724767])
>>> np.sin(arr) # 计算元素正弦值
array([-0.01157065,  0.68254881,  0.99687093,  0.94317295,  0.03957797, 0.47806927,  0.45050305, -0.52583679])
>>> np.sinh(arr) # 计算双曲正弦值
array([-0.01157117,  0.82392859,  2.5072636 ,  1.56828342,  0.03959865, 0.51935396,  0.48452592, -0.58242782])
>>> np.tan(arr) # 计算元素正切值
array([-1.15714291e-02,  9.33923706e-01, -1.26111917e+01,  2.83829848e+00, 3.96090007e-02,  5.44298323e-01,  5.04609910e-01, -6.18205694e-01])
>>> np.tanh(arr) # 计算双曲正切值
array([-0.0115704 ,  0.63589081,  0.92884738,  0.84317374,  0.03956764, 0.46090138,  0.43603846, -0.5032871 ])
>>> np.arccos(arr) # 反余弦
__main__:1: RuntimeWarning: invalid value encountered in arccos
array([1.5823675 , 0.72085074,        nan,        nan, 1.53119767, 1.04898043, 1.08452948, 2.15759564])
>>> np.arccosh(arr) # 反双曲余弦
__main__:1: RuntimeWarning: invalid value encountered in arccosh
array([       nan,        nan, 1.08595658, 0.66872292,        nan,      nan,        nan,        nan])
>>> np.arcsin(arr) # 反正弦
__main__:1: RuntimeWarning: invalid value encountered in arcsin
array([-0.01157117,  0.84994558,         nan,         nan,  0.03959865, 0.5218159 ,  0.48626685, -0.58679931])
>>> np.arcsinh(arr) # 反双曲正弦
array([-0.01157065,  0.69414247,  1.27515042,  1.03633224,  0.03957797, 0.47982968,  0.45180056, -0.52871868])
>>> np.arctan(arr) # 反正切
array([-0.0115704 ,  0.64429711,  1.02591237,  0.88898988,  0.03956764, 0.462411  ,  0.43717069, -0.50567839])
>>> np.arctanh(arr) # 反双曲正切
__main__:1: RuntimeWarning: invalid value encountered in arctanh
array([-0.01157143,  0.97580571,         nan,         nan,  0.03960901, 0.54724851,  0.50664718, -0.62369952])
>>>
>>> np.logical_not([True, False, 0, 1]) # 逻辑非
array([False,  True,  True, False])
```

* 二元通用函数

```python
>>> arr1 = np.random.randn(8)
>>> arr2 = np.random.randn(8)
>>> arr1
array([-0.31686956,  0.88155789, -1.9439398 , -1.79328575,  0.90508887, 0.86687852, -0.30566788,  1.98680926])
>>> arr2
array([ 1.26492803,  0.38370352, -1.8504629 , -1.02338951, -0.40395344, -1.43352599, -0.01769304,  0.40700216])
>>>
>>> np.add(arr1, arr2) # 两个数组对应元素相加
array([ 0.94805847,  1.26526141, -3.7944027 , -2.81667526,  0.50113543, -0.56664747, -0.32336092,  2.39381142])
>>> np.subtract(arr1, arr2) # 两个数组对应元素相减
array([-1.58179759,  0.49785437, -0.0934769 , -0.76989624,  1.30904231, 2.3004045 , -0.28797484,  1.5798071 ])
>>> np.multiply(arr1, arr2) # 两个数组对应元素相乘
array([-0.40081719,  0.33825686,  3.59718847,  1.83522982, -0.36561376, -1.24269288,  0.00540819,  0.80863566])
>>> np.divide(arr1, arr2) # 两个数组对应元素相除
array([-0.25050402,  2.29749754,  1.05051541,  1.75230031, -2.24057722, -0.60471768, 17.27616401,  4.88156936])
>>> np.floor_divide(arr1, arr2) # 两个数组对应元素相除后结果向下取整
array([-1.,  2.,  1.,  1., -3., -1., 17.,  4.])
>>> np.power(arr2, arr1) # 两个数组对应元素计算幂，即arr2[i]^arr1[i]
array([0.92823609, 0.42980177,        nan,        nan,        nan,        nan,        nan, 0.16762668])
>>>
>>> np.maximum(arr1, arr2) # 两个数组对应元素取最大值
array([ 1.26492803,  0.88155789, -1.8504629 , -1.02338951,  0.90508887,  0.86687852, -0.01769304,  1.98680926])
>>> np.fmax(arr1, arr2) # # 两个数组对应元素取最大值，忽略 NaN
array([ 1.26492803,  0.88155789, -1.8504629 , -1.02338951,  0.90508887, 0.86687852, -0.01769304,  1.98680926])
>>> np.minimum(arr1, arr2) # 两个数组对应元素取最小值
array([-0.31686956,  0.38370352, -1.9439398 , -1.79328575, -0.40395344, -1.43352599, -0.30566788,  0.40700216])
>>> np.fmin(arr1, arr2) # # 两个数组对应元素取最小值，忽略NaN
array([-0.31686956,  0.38370352, -1.9439398 , -1.79328575, -0.40395344, -1.43352599, -0.30566788,  0.40700216])
>>>
>>> np.mod(arr1, arr2) # 两个数组对应元素取摸
array([ 0.94805847,  0.11415085, -0.0934769 , -0.76989624, -0.30677144, -0.56664747, -0.00488618,  0.35880063])
>>> np.copysign(arr1, arr2) # 将第二个元素对应位置的符号复制给第一个元素对应位置的元素
array([ 0.31686956,  0.88155789, -1.9439398 , -1.79328575, -0.90508887, -0.86687852, -0.30566788,  1.98680926])
>>>
>>> np.greater(arr1, arr2) # 两个数组对应元素做 > 运算，返回布尔型数组
array([False,  True, False, False,  True,  True, False,  True])
>>> np.greater_equal(arr1, arr2) # 两个数组对应元素 >= 运算，返回布尔型数组
array([False,  True, False, False,  True,  True, False,  True])
>>> np.less(arr1, arr2) # 两个数组对应元素做 < 运算，返回布尔型数组
array([ True, False,  True,  True, False, False,  True, False])
>>> np.less_equal(arr1, arr2) # 两个数组对应元素做 <= 运算，返回布尔型数组
array([ True, False,  True,  True, False, False,  True, False])
>>> np.equal(arr1, arr2) # 两个数组对应元素做 = 运算，返回布尔型数组
array([False, False, False, False, False, False, False, False])
>>> np.not_equal(arr1, arr2) # 两个数组对应元素做 != 运算，返回布尔型数组
array([ True,  True,  True,  True,  True,  True,  True,  True])
>>>
>>> np.logical_and([True, False], [False, False]) # 两个数组对应元素逻辑 与 运算 &
array([False, False])
>>> np.logical_or([True, False], [False, False]) # 两个数组对应元素逻辑 或 运算 | 
array([ True, False])
>>> np.logical_xor([True, False], [False, False]) # 两个数组对应元素逻辑 异或 运算 ^
array([ True, False])
```

* 常见统计方法

```python
>>> arr = np.random.randn(5, 4)
>>> arr
array([[-0.30330993,  0.52492227,  0.08955927, -1.44936394],
       [ 1.09186726, -0.65869004,  1.32978699, -0.78818863],
       [-0.2230933 ,  0.14603332,  0.68055246, -1.24933823],
       [-1.07323045,  1.93311226,  0.16418999, -0.62634364],
       [ 0.20567264, -1.04623413, -1.39016292,  1.02832624]])
>>> arr.mean() # 数组的算术平均数
-0.08069662535630753
>>> np.mean(arr) # 同上
-0.08069662535630753
>>> arr.mean(axis = 1) # 轴 1 上元素的算术平均数，即计算每行的算术平均数
array([-0.28454808,  0.24369389, -0.16146144,  0.09943204, -0.30059954])
>>>
>>> arr.sum() # 求和
-1.6139325071261508
>>> arr.sum(axis = 0) # 轴 0 上的求和，即计算每列的和
array([-0.30209378,  0.89914368,  0.87392579, -3.08490819])
>>>
>>> arr.std() # 方差
0.9458229152201936
>>> arr.std(axis = 0) # 轴 0 上的方差
array([0.70849338, 1.03928617, 0.89958524, 0.87511972])
>>> arr.var() # 标准差
0.8945809869556254
>>> arr.var(axis = 0)
array([0.50196287, 1.08011574, 0.8092536 , 0.76583453])
>>>
>>> arr.min() # 最小值
-1.4493639352558474
>>> arr.min(axis = 0)
array([-1.07323045, -1.04623413, -1.39016292, -1.44936394])
>>> arr.max() # 最大值
1.9331122581547218
>>> arr.max(axis = 0)
array([1.09186726, 1.93311226, 1.32978699, 1.02832624])
>>> arr.argmax() # 最大值的索引位置，数组从左到右，从上到下索引
13
>>> arr.argmax(axis = 1) 
array([1, 2, 2, 1, 3], dtype=int64)
>>> arr.argmin() # 最小值的索引位置
3
>>> arr.argmin(axis = 1)
array([3, 3, 3, 0, 2], dtype=int64)
>>>
>>> arr = np.arange(9).reshape(3, 3)
>>> arr
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> arr.cumsum() # 元素累加和
array([ 0,  1,  3,  6, 10, 15, 21, 28, 36], dtype=int32)
>>> arr.cumsum(axis = 0)
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
>>> arr.cumprod() # 元素累乘和
array([0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int32)
>>> arr.cumprod(axis = 1)
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]], dtype=int32)
>>>
>>> (arr > 4)
array([[False, False, False],
       [False, False,  True],
       [ True,  True,  True]])
>>> (arr > 4).sum() # 正值数量
4
>>> (arr > 4).any() # 是否存在 True
True
>>> (arr > 4).all() # 是否全部为 True
False
>>>
>>> arr = np.random.randn(5, 3)
>>> arr
array([[-1.00259189, -0.74688582, -0.81336468],
       [ 0.67672212,  0.22617135, -0.49789534],
       [-1.42797901,  1.56661844, -1.09601829],
       [-0.75874955,  0.78507379, -0.6912824 ],
       [ 0.39688763, -0.6546862 ,  0.49659272]])
>>> arr.sort() # 排序
>>> arr
array([[-1.00259189, -0.81336468, -0.74688582],
       [-0.49789534,  0.22617135,  0.67672212],
       [-1.42797901, -1.09601829,  1.56661844],
       [-0.75874955, -0.6912824 ,  0.78507379],
       [-0.6546862 ,  0.39688763,  0.49659272]])
>>> arr.sort(axis = 0)
>>> arr
array([[-1.42797901, -1.09601829, -0.74688582],
       [-1.00259189, -0.81336468,  0.49659272],
       [-0.75874955, -0.6912824 ,  0.67672212],
       [-0.6546862 ,  0.22617135,  0.78507379],
       [-0.49789534,  0.39688763,  1.56661844]])
```

* 数组逻辑计算

```python
>>> names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
>>> np.unique(names) # 求去重数组
array(['Bob', 'Joe', 'Will'], dtype='<U4')
>>>
>>> arr1 = [1, 2, 3, 4]
>>> arr1 = np.array([1, 2, 3, 4])
>>> arr2 = np.array([2, 3, 4, 5])
>>> np.intersect1d(arr1, arr2) # 求交集
array([2, 3, 4])
>>> np.union1d(arr1, arr2) # 求并集
array([1, 2, 3, 4, 5])
>>> np.in1d(arr1, arr2) # 求存在于arr2 中的 arr1 元素的布尔型数组
array([False,  True,  True,  True])
>>> np.setdiff1d(arr1, arr2) # 求差集 arr1 - arr2
array([1])
>>> np.setxor1d(arr1, arr2) # 求对称差，即 (arr1 - arr2) + (arr2 - arr1)
array([1, 5])
```

* `meshgrid()`和`where()`

```python
>>> points = np.arange(-1, 1, 0.1)
>>> points
array([-1.00000000e+00, -9.00000000e-01, -8.00000000e-01, -7.00000000e-01,
       -6.00000000e-01, -5.00000000e-01, -4.00000000e-01, -3.00000000e-01,
       -2.00000000e-01, -1.00000000e-01, -2.22044605e-16,  1.00000000e-01,
        2.00000000e-01,  3.00000000e-01,  4.00000000e-01,  5.00000000e-01,
        6.00000000e-01,  7.00000000e-01,  8.00000000e-01,  9.00000000e-01])
>>> xs, ys = np.meshgrid(points, points) # 生成 points 范围内的坐标对
>>> xs
array([[-1.00000000e+00, -9.00000000e-01, -8.00000000e-01,
        -7.00000000e-01, -6.00000000e-01, -5.00000000e-01,
        -4.00000000e-01, -3.00000000e-01, -2.00000000e-01,
        -1.00000000e-01, -2.22044605e-16,  1.00000000e-01,
         2.00000000e-01,  3.00000000e-01,  4.00000000e-01,
         5.00000000e-01,  6.00000000e-01,  7.00000000e-01,
         8.00000000e-01,  9.00000000e-01],
       [-1.00000000e+00, -9.00000000e-01, -8.00000000e-01,
        -7.00000000e-01, -6.00000000e-01, -5.00000000e-01,
        -4.00000000e-01, -3.00000000e-01, -2.00000000e-01,
        -1.00000000e-01, -2.22044605e-16,  1.00000000e-01,
         2.00000000e-01,  3.00000000e-01,  4.00000000e-01,
         5.00000000e-01,  6.00000000e-01,  7.00000000e-01,
         8.00000000e-01,  9.00000000e-01],
       ...,
       [-1.00000000e+00, -9.00000000e-01, -8.00000000e-01,
        -7.00000000e-01, -6.00000000e-01, -5.00000000e-01,
        -4.00000000e-01, -3.00000000e-01, -2.00000000e-01,
        -1.00000000e-01, -2.22044605e-16,  1.00000000e-01,
         2.00000000e-01,  3.00000000e-01,  4.00000000e-01,
         5.00000000e-01,  6.00000000e-01,  7.00000000e-01,
         8.00000000e-01,  9.00000000e-01]])
>>> ys
array([[-1.00000000e+00, -1.00000000e+00, -1.00000000e+00,
        -1.00000000e+00, -1.00000000e+00, -1.00000000e+00,
        -1.00000000e+00, -1.00000000e+00, -1.00000000e+00,
        -1.00000000e+00, -1.00000000e+00, -1.00000000e+00,
        -1.00000000e+00, -1.00000000e+00, -1.00000000e+00,
        -1.00000000e+00, -1.00000000e+00, -1.00000000e+00,
        -1.00000000e+00, -1.00000000e+00],
       [-9.00000000e-01, -9.00000000e-01, -9.00000000e-01,
        -9.00000000e-01, -9.00000000e-01, -9.00000000e-01,
        -9.00000000e-01, -9.00000000e-01, -9.00000000e-01,
        -9.00000000e-01, -9.00000000e-01, -9.00000000e-01,
        -9.00000000e-01, -9.00000000e-01, -9.00000000e-01,
        -9.00000000e-01, -9.00000000e-01, -9.00000000e-01,
        -9.00000000e-01, -9.00000000e-01],
       ...,
       [ 9.00000000e-01,  9.00000000e-01,  9.00000000e-01,
         9.00000000e-01,  9.00000000e-01,  9.00000000e-01,
         9.00000000e-01,  9.00000000e-01,  9.00000000e-01,
         9.00000000e-01,  9.00000000e-01,  9.00000000e-01,
         9.00000000e-01,  9.00000000e-01,  9.00000000e-01,
         9.00000000e-01,  9.00000000e-01,  9.00000000e-01,
         9.00000000e-01,  9.00000000e-01]])
>>>
>>> xarr = np.arange(1.1, 1.5, 0.1)
>>> xarr
array([1.1, 1.2, 1.3, 1.4])
>>> xarr = np.arange(1.1, 1.6, 0.1)
>>> xarr
array([1.1, 1.2, 1.3, 1.4, 1.5])
>>> yarr = np.arange(2.1, 2.6, 0.1)
>>> yarr
array([2.1, 2.2, 2.3, 2.4, 2.5])
>>> cond = np.array([True, False, True, True, False])
>>> cond
array([ True, False,  True,  True, False])
>>> result = np.where(cond, xarr, yarr) # 等效于 result = [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]，做三目运算
>>> result
array([1.1, 2.2, 1.3, 1.4, 2.5])
```

### 7.3.3 线性代数

### 7.3.4 `IO`操作