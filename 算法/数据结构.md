## 2.1 数据结构

>date: 2019-03-23

![](../assets/images/21.jpg)

### 2.1.1 线性表

#### 顺序表

表中元素顺序存放在一片足够大的连续存储区内，元素依次存放，元素间的逻辑关系通过存储区内的物理位置表示。

假设存储区的起始位置的内存地址为$l_0$，存储一个元素所需$c$个单位的存储空间，则第$i$个元素的位置为$l_0 + c \times i$。

```python
class List(object):
    def __init__(self):
        self.list = []
    
    def append(self, elem): # 时间复杂度O(1)
        self.list.append(elem)

    def prepend(self, elem): # 时间复杂度O(n)
        self.list.insert(0, elem)
    
    def size(self):
        return len(self.list)

    def is_empty(self):
        if self.size == 0:
            return True
        else:
            return False
    
    def insert(self, elem, index): # 时间复杂度平均和最坏都为O(n)
        self.list.insert(index, elem)

    def search(self, elem): # 时间复杂度O(n)
        return self.list.index(elem) if elem in self.list else -1
    
    def get(self, index): # 时间复杂度O(1)
        return self.list[index]

    def del(self, index): # 时间复杂度O(n)
        del self.list[index]
```

#### 链表

* 单向链表

单向链表是由一个个二元组组成的节点连接起来的顺序表，其元素域保存元素的值，链接域保存着到下一个节点的标识，称为指针。

常见的单向链表的操作有：创建空表，删除表，判断是否为空表，首、尾、指定位置加入元素，首、尾、指定位置删除元素等。

```python
class LinkedListNode(object): # 定义节点类
    def __init__(self, elem, next_ = None):
        self.elem = elem # 元素域
        self.next = next_ # 链接域

class LinkedList(object):
    def __init__(self):
        self._head = None # 定义头节点
    
    def is_empty(self): # O(1)
        return self._head is None
    
    def prepend(self, elem): # O(1)
        self._head = LinkedListNode(elem, self._head)
    
    def append(self, elem): # O(n)
        if self._head is None:
            self._head = LinkedListNode()
            return
        p = self._head
        while p.next is not None:
            p = p.next
        p.next = LinkedListNode(elem)
    
    def remove_first(self): # O(1)
        if self._head is None:
            raise LinkedListUnderflow('List is empty')
        e = self._head.elem
        self._head = self._head.next
        return e
    
    def remove_last(self): # O(n)
        if self._head is None:
            raise LinkedListUnderflow('List is empty')
        p = self._head
        if p.next is None:
            e = p.elem
            self._head = None
            return e
        while p.next.next is not None:
            p = p.next
        e = p.next.elem
        p.next = None
        return e
    
    def search(self, elem): # O(n)
        p = self._head
        while p is not None:
            if p.elem == elem:
                return True
            p = p.next
        return False
    
    def reverse(self): # O(n)
        p = None
        while self._head is not None:
            q = self._head
            self._head = q.next # 取出现在的节点
            q.next = p # 将当前节点的前置元素设为之前一次循环的节点，即前置节点
            p = q # 当前节点放入下次循环中，作为前置节点
        self._head = p
```

* 双向链表

基于单向链表节点的基础上，增加一个前向指针，此时链接域为前向指针和后向指针，分别指向该节点的前面元素和后面元素。

```python
class DoubleLinkedListNode(LinkedListNode):
    def __init__(self, elem, prev = None, next_ = None):
        super().__init__(self, elem, next_)
        self.prev = prev
    
class DoubleLinkedList(LinkedList):
    def __init__(self):
        super().__init__()
        self._rear = None # 尾节点
    
    def prepend(self, elem): # O(1)
        p = DoubleLinkedListNode(elem, None, self._head) # 定义一个双向节点
        if self._head is None:
            self._rear = p # 尾节点为p
        else:
            p.next.prev = p # p.next为self._head，将其前向指针指向p
        self._head = p # 头指针置为 p
    
    def append(self, elem): # O(1)
        p = DoubleLinkedListNode(elem, self._rear, None) # 定义一个双向节点
        if self._head is None:
            self._head = p
        else:
            p.prev.next = p # p.prev为self._rear，将其后向指向p
        self._rear = p # 尾节点置为p
    
    def remove_first(self): # O(1)
        if self._head is None:
            raise LinkedListUnderflow('List is empty')
        e = self._head.elem
        self._head = self._head.next
        if self._head is not None:
            self._head.prev = None
        return e

    def remove_last(self): # O(1)
        if self._head is None:
            raise LinkedListUnderflow('List is empty')
        e = self._rear.elem
        self._rear = self._rear.prev
        if self._rear is None:
            self._head = None
        else:
            self._rear.next = None
        return e
    
    def reverse(self):
        p = None
        current = self._head # 当前节点
        while current is not None:
            p = current.prev # 得到当前节点的前向节点
            current.prev = current.next # 当前节点的前向节点置为其后置节点
            current.next = p # 当前节点的后向节点置为其前向节点
            current = current.prev # 向后遍历
        if p is not None:
            self._head = p.prev # 头节点设为最后的节点
```

### 2.1.2 栈和队列

#### 栈

#### 队列

### 2.1.3 二叉树和树

#### 二叉树

#### 优先队列

#### 哈夫曼树

#### 平衡二叉树

#### 多分支排序树

#### 树

### 2.1.4 图

#### 
