## 2.2 经典算法

>date: 2019-02-25

![](../assets/images/22.jpg)

### 2.2.1 经典排序算法

##### 直接插入排序

直接插入排序的基本思想是：每次将待排序的记录，按照大小插入到已经排好序的子序列中适当的位置，知道全部记录插入完成为止。

```python
def insert_sort(relist):
    for i in range(len(relist)):
        for j in range(i): # j < i 
            if relist[j] > relist[i]: # 此时 relist[i] 前存在 relist[j] ，并且relist[j] > relist[i]
                relist.insert(j, relist[i]) # 在 j 位置插入 relist[i]
                relist.pop(i + 1) # 原来位置的 relist[i] 索引向后移动一位，所以是 i + 1
                break
    return relist

def insert_sort(relist):
    for i in range(len(relist)):
        for j in range(i):
            if relist[j] > relist[i]:
                relist[j], relist[i] = relist[i], relist[j] # 交换 relist[j] 和 relist[i] 位置
    return relist
```

![直接插入排序](../assets/images/221_01.gif)

**时间复杂度：**`O(N^2)`

假设被排序的数列中有`N`个数。遍历一趟的时间复杂度是`O(N)`，需要遍历多少次呢？`(N-1)！`因此，直接插入排序的时间复杂度是`O(N^2)`。

**稳定性：**稳定

假设在数列中存在`a[i]=a[j]`，若在排序之前，`a[i]`在`a[j]`前面；并且排序之后，`a[i]`仍然在`a[j]`前面。则这个排序算法是稳定的。

##### 希尔排序

希尔排序的基本思想是：对于`n`个待排序的数列，取一个小于`n`的整数`gap`(`gap`被称为步长)将待排序元素分成若干个组子序列，所有距离为`gap`的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。

这一趟排序完成之后，每一个组的元素都是有序的。然后减小`gap`的值，并重复执行上述的分组和排序。重复这样的操作，当`gap=1`时，整个数列就是有序的。

```python
def shell_sort(relist):
    gap = len(relist) // 2
    while gap >= 1:
        for i in range(gap, len(relist)): # 分组
            if relist[i] < relist[i - gap]:
                relist[i], relist[i - gap] = relist[i - gap], relist[i] # 进行直接插入排序
        gap //= 2
    return relist
```

**时间复杂度：**`O(N^(3/2)) ~ O(N^2)`

希尔排序的时间复杂度与增量(即，步长gap)的选取有关。例如，当增量为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为`O(N^2)`，而`Hibbard`增量(`2^k - 1`)的希尔排序的时间复杂度为`O(N^(3/2))`。

**稳定性：**不稳定

假设在数列中存在`a[i]=a[j]`，若在排序之前，`a[i]`在`a[j]`前面；并且排序之后，`a[i]`仍然在`a[j]`前面。则这个排序算法是稳定的。

##### 选择排序

选择排序的基本思想是：首先在未排序的数列中找到最小(或最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(或最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```python
def select_sort(relist):
    for i in range(len(relist)):
        tag = i
        for j in range(i + 1, len(relist)): # 分组，已经排序的组为relist[: i]，未排序的组为relist[i + 1:]
            if relist[j] < relist[tag]:
                tag = j
        if tag != i:
            relist[i], relist[tag] = relist[tag], relist[i] # 排序
    return relist
```

**时间复杂度：**`O(N^2)`

假设被排序的数列中有`N`个数。遍历一趟的时间复杂度是`O(N)`，需要遍历多少次呢？`(N-1)！`因此，选择排序的时间复杂度是`O(N^2)`。

**稳定性：**稳定

假设在数列中存在`a[i]=a[j]`，若在排序之前，`a[i]`在`a[j]`前面；并且排序之后，`a[i]`仍然在`a[j]`前面。则这个排序算法是稳定的。

##### 堆排序

堆排序的基本思想是：将乱序数列构造成最大堆（最小堆），然后将堆顶元素——最大值（最小值）放到数列最后，重新构成无序区和有序区，对无序区进行堆排序后再进行上述操作，最后的数列是升序（降序）排序的。

```python
def heap_sort(relist): # 最大堆排序
    start = len(relist) // 2 - 1
    for i in range(start, -1, -1): # 从下向上遍历，循环结束得到最大堆
        max_heap_down(relist, i, len(relist) - 1)
    for i in range(len(relist) - 1, -1, -1): # 循环全部节点
        relist[0], relist[i] = relist[i], relist[0] # 不断将最大元素下沉到最后的位置，形成无序区relist[:i - 1], relist[i:]
        max_heap_down(relist, 0, i - 1) # 重新调整无序区最大堆
    return relist

def max_heap_down(relist, start, end):
    root = start
    while True:
        child = 2 * root + 1 # 左节点
        if child > end: # 左节点比最后一个节点大，跳出循环
            break
        if child + 1 <= end and relist[child] < relist[child + 1]:
            child += 1 # 找出左右节点中最大的
        if relist[child] > relist[root]:
            relist[child], relist[root] = relist[root], relist[child] # 交换子节点和父节点
            root = child # 再从子节点开始
        else:
            break
```

**时间复杂度：**`O(N*lgN)`

假设被排序的数列中有`N`个数。遍历一趟的时间复杂度是`O(N)`，需要遍历多少次呢？

堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是`lg(N+1)`。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过`lg(2N)`。因此，遍历一趟的时间复杂度是`O(N)`，而遍历次数介于`lg(N+1)`和`lg(2N)`之间；因此得出它的时间复杂度是`O(N*lgN)`。

**稳定性：**不稳定

它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化，所以是不稳定的。

##### 冒泡排序

冒泡排序的基本思想是：遍历多次需要排序的数列，每次遍历，依次比较前后两数的大小，如果前者比后者大，就交换两者位置。重复直到排好序。

```python
def bubble_sort(relist):
    for i in range(len(relist) - 1, -1, -1): # 逆向遍历，生成无序区 relist[: i]
        for j in range(i):
            if relist[j] > relist[j + 1]: # 对无序区内的元素进行依次的前后比较，交换符合条件的元素
                relist[j], relist[j + 1] = relist[j + 1], relist[j]
    return relist

def bubble_sort(relist):
    for i in range(len(relist) - 1, -1, -1): # 逆向遍历，生成无序区 relist[: i]
        flag = 0 # 标记是否进行交换
        for j in range(i):
            if relist[j] > relist[j + 1]: # 对无序区内的元素进行依次的前后比较，交换符合条件的元素
                relist[j], relist[j + 1] = relist[j + 1], relist[j]
                flag = 1
        if flag == 0: # 若没发生交换，则说明该趟排序数列已有序
            break
    return relist
```

**时间复杂度：**`O(N2)`

假设被排序的数列中有`N`个数。遍历一趟的时间复杂度是`O(N)`，需要遍历多少次呢？`(N-1)！`因此，冒泡排序的时间复杂度是`O(N^2)`。

**稳定性：**稳定

假设在数列中存在`a[i]=a[j]`，若在排序之前，`a[i]`在`a[j]`前面；并且排序之后，`a[i]`仍然在`a[j]`前面，所以算法是稳定的。

##### 快速排序

快速排序的基本思想是：选择一个基准数，将数据分成前后两部分，然后前部分全部数据需要小于后部分全部数据。递归进行这个过程，将数列变成有序。

```python
def quick_sort(relist, left, right):
    if left > right:
        return
    low, high = left, right
    base_val = relist[low]
    while left < right:
        while left < right and relist[right] > base_val:
            right -= 1
        relist[left] = relist[right]
        while left < right and relist[left] <= base_val:
            left += 1
        relist[right] = relist[left]
    relist[right] = base_val
    quick_sort(relist, low, left - 1)
    quick_sort(relist, left + 1, high)

def quick_sort(A, p, r):
    if p < r:
        q = partition(A, p, r) # 得到新的基准值，递归进行前后两个子序列的quick_sort()
        quick_sort(A, p, q - 1)
        quick_sort(A, q + 1, r)
 
def partition(A, p, r):
    x = A[r] # 基准
    i = p - 1
    for j in range(p, r):
        if A[j] <= x: # 与基准比较
            i += 1
            A[i], A[j] = A[j], A[i] # 比基准小的数是向前移动
    A[i + 1], A[r] = A[r], A[i + 1] # 当前基准向前移动
    return i + 1
```

![快速排序分片过程](../assets/images/221_02.jpg)

**时间复杂度：**最坏情况是`O(N^2)`，平均情况是`O(N*lgN)`

快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度。

根据完全二叉树的定义，它的深度至少是`lg(N+1)`。因此，快速排序的遍历次数最少是`lg(N+1)`次。

将快速排序看作一棵二叉树，它的深度最大是`N`。因此，快读排序的遍历次数最多是`N`次。

**稳定性：**不稳定

##### 归并排序

归并排序的基本思想是：将数列平分成前后两个区间，对前后两个区间进行归并排序，得到前后排序好的区间后进行合并即可得到排序好的数列。

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left_arr = merge_sort(arr[:mid])
    right_arr = merge_sort(arr[mid:])
    return merge(left_arr, right_arr)

def merge(left_arr, right_arr): # 合并前后序列
    i, j = 0, 0
    result = [] # 有序序列
    while i < len(left_arr) and j < len(right_arr): # 依次递归前后的序列
        if left_arr[i] <= right_arr[j]:
            result.append(left_arr[i])
            i += 1
        else:
            result.append(right_arr[j])
            j += 1
    result += left_arr[i:] # 将未整理的前序列加入
    result += right_arr[j:] # 将未整理的后序列加入
    return result
```

**时间复杂度：**`O(N*lgN)`

归并排序的形式就是一棵完全二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是`O(N*lgN)`

**稳定性：**稳定

##### 桶排序

桶排序的基本思想是：把数组`a`划分为`n`个大小相同子区间（桶），每个子区间各自排序，最后合并。桶排序要求数据的分布必须均匀，不然可能会失效。

```python
def bucket_sort(relist):
    buckets = [0] * (max(relist) - min(relist) + 1) # 根据序列中最大最小的元素生成 buckets 个桶
    for i in range(len(relist)):
        buckets[relist[i] - min(relist)] += 1 # 对应编号的桶存在序列中的数据的累加 1
    result = []
    for j in range(len(buckets)):
        if buckets[j] != 0:
            result.append(j + min(relist)) # 整理数据的结果
    return result
```

**时间复杂度：**`O(N)`

当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间`O(N)`，但空间复杂度为`O(N+M)`，`M`为桶的数量

**稳定性：**稳定

##### 基数排序

基数排序的基本思想是：将待排序数据拆分成多个关键字进行排序。

```python
import math
 
def radix_sort(relist, radix = 10):
    K = int(math.ceil(math.log(max(relist), radix))) # 用K位数可表示任意整数
    bucket = [[] for i in range(radix)] # 不能用 [[]]*radix
    for i in range(1, K + 1): # K次循环
        for val in relist:
            bucket[int(val % (radix**i)/(radix**(i-1)))].append(val) # 析取整数第K位数字 （从低到高）
        del relist[:]
        for each in bucket:
            relist.extend(each) # 桶合并
        bucket = [[] for i in range(radix)]
```
**时间复杂度：**`O (Nlg(r)M)`

`M`为桶的数量，`r`为取的基数

**稳定性：**稳定

### 2.2.2 查找算法

顺序查找

二分查找

哈希查找

二叉树

红黑树

`B tree` `B+ tree`

`HashMap`

### 2.2.3 经典递归算法

二分查找

欧几里德算法

汉诺塔问题

阶乘

### 2.2.4 穷举法

泊松算法

### 2.2.5 贪心法

背包问题

普里姆算法

### 2.2.6 分治法

循环赛日常表

棋盘覆盖

### 2.2.7 动态规划

最长公共子序列

### 2.2.8 回溯法

八皇后

### 2.2.9 搜索

树、图遍历

深度优先搜索 DFS

剪枝 最优化剪枝和可行性剪枝

广度优先搜索 BFS

A*算法

回溯算法

蒙特卡洛树搜索

散列函数

记忆化搜索

### 2.2.10 数学

位运算

质数（素数）

博弈论相关

密码学经典算法

### 2.2.11 图论

最小生成树

单源最短路径

Dijkstra算法

### 2.2.12 其它

约瑟夫杀人法

斐波拉切数列

布隆算法

`KMP`算法

