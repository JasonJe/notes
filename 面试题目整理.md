# 算法

1. 在列表中寻找第 `k` 大的数

快排 `NlgN`

最小堆 `NlgN`

构造一个大小为`k`的最小堆，堆中根节点为最小值

2. 全排列
```python
# 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
#
# 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
#
# 必须原地修改，只允许使用额外常数空间。
#
# 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
#
# 1,2,3 → 1,3,2
# 3,2,1 → 1,2,3
# 1,1,5 → 1,5,1
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums) - 1, -1, -1):
            if nums[i - 1] < nums[i]:
                position = i - 1
                for j in range(len(nums) - 1, position - 1, -1):
                    if nums[i] < nums[j]:
                        nums[i], nums[j] = nums[j], nums[i]
                        nums[i + 1:] = nums[:i:-1]
                        break
        print(nums)

class Solution(object):
    def reverse(self, nums, st):
        lena = len(nums)
        for i in range(st, st+int((lena-st)/2)):
            nums[i], nums[lena-(i-st)-1] = nums[lena-(i-st)-1], nums[i]

    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        lena = len(nums)
        for i in range(1, lena):
            ri = lena-i-1
            if nums[ri] < nums[ri+1]:
                j = ri+1
                while j < lena and nums[j] > nums[ri]:
                    j += 1
                j -= 1
                nums[ri], nums[j] = nums[j], nums[ri]
                self.reverse(nums, ri+1)
                print(nums)
                return

        nums.sort()


if __name__ == '__main__':
    sol = Solution()
    nums = [1, 2]
    data = sol.nextPermutation(nums)
    print(data)
```

3. 统计字符串中每个单词出现的个数

```python
char_dict = {}
for i in string:
	if i not in char_dict:
		char_dict.update({
			i: 1
		})
	else:
		char_dict[i] += 1
print(char_dict)
```

4. 两点连成的线段，看是否相交

`(1, 1) -- (6, 6)`，`(1, 4) -- (8, 2)`

判断两线段为对角线的矩形是否相交，若不相交，则两线段一定不相交

而判断两个矩形是否相交，只要任一矩形的最右端都大于另一矩形的最左端且任一矩形最高端大于另一矩形的最低端，则两矩形相交；反之，若其中任一条件不满足，两矩形不相交。

5. `KMP`算法

```python
def partial_table(pattern):
    prefix = set()
    table = [0]
    for i in range(1, len(pattern)):
        prefix.add(pattern[:i])
        suffix = set()
        for j in range(i, 0, -1):
            suffix.add(pattern[j:i + 1]) # 后缀
        intersection = prefix & suffix # 交集
        if intersection:
            table.append(max([len(s) for s in intersection]))
        else:
            table.append(0)
    return table

def kmp(pattern, string):
    p = len(pattern)
    s = len(string)
    cursor = 0
    table = partial_table(pattern)
    while cursor <= s - p: # 当指针到达边缘，长度不够跳出
        for i in range(p):
            if pattern[i] != string[cursor + i]:
                cursor += max(i - table[i - 1], 1) # 移动位数 = 已匹配的字符数 - 对应的部分匹配值
                break
        else:
            return cursor
    return -1
```

6. 二叉树

7. 计算复杂度，求`f(n)=n*f(n-1)+O(n)`的通项

8. 通配符匹配

https://leetcode-cn.com/problems/wildcard-matching/description/

9. 十六进制字符串和十进制字符串的相互转换

10. 把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，不能申请额外的空间

设置两个下标`p1`、`p2`

同时指向字符串的末尾，让`p1`找到第一次出现为大写的字母的位置，然后从`p1`至`p2`两两交换，之后让`p1--`，`p2--`，重复以上，直到`p1`小于`0`为止

11. `0` 到 `9999` 这 `1` 万个数中有多少个数字 `7` ？（请不要理解为多少个数包含 7）

总共有四位数，每位数的可能分别有`10`种（`0～9`）。 

每一个位，都会出现`0-9`的交替，实际上在出现`7`这个角度，各个位是一样的。

现在假设个位固定为`7`，那么其他的位数的变化数量是`10 * 10 * 10 = 1000`种。 
就是说数字`7`在个位出现的次数为`1000`。

以此类推，数字`7`在十位、百位、千位出现的次数也是`1000`。

故答案为 `4 * 1000 = 4000`

12. 有`1`亿个`IP`地址，怎么找出访问次数最多的`IP`

`IP`地址是由`32`位二进制数据来表示的，每`8`位表示一段，共有四段。四段自然就是`4×8=32`位了。

所以其最多有`2^32=4G`种取值可能，所以不能完全加载到内存中

先做`hash`，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数,
然后找出上一步求出的数据中重复次数最多的一个就是所求。

分而治之

`map`：

按照`IP`地址的`hash(IP)%1024`值，将海量日志存储到`1024`个小文件中，每个小文件最多包含`4M`个IP地址。
 
`reduce`：

对于每个小文件，可以构建一个`IP`作为`key`，出现次数作为`value`的`hash_map`，并记录当前出现次数最多的`1`个`IP`地址。 
有了`1024`个小文件中的出现次数最多的`IP`，就可以轻松得到总体上出现次数最多的`IP`。

13. 复杂链表的复制

# 操作系统

1. 进程和线程区别

进程拥有独立的地址空间，线程拥有自己的堆栈和局部变量，但是线程之间没有单独的地址空间。

线程是一个进程的不同执行路径，一个程序至少有一个进程，一个进程至少有一个线程。线程不能单独执行。

进程间切换，消耗资源大，效率较差。对需要同时进行且要共享变量的并发操作，只能用线程

2. 多线程和锁

多线程同时对同一个对象进行读写操作，很容易出现一些难以预料的问题，所以需要对对象进行加锁操作，在同一时刻只允许一个线程对某个对象进行操作。

* 临界资源

能够被多个线程共享的数据/资源

* 临界区

对临界资源进行操作程序

* 线程互斥

在同一时刻只允许一个进程运行其中的程序片，具有排他性和唯一性

* 线程同步

在互斥的基础上，实现进程之间的有序访问

* 互斥锁

对临界区进行保护，实现线程间的互斥

* 死锁

指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态

3. 生产者消费者队列

* 生产者和消费者模式

在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

* 生产者消费者模式

生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

4. `epoll`的底层实现原理

`select` 对事件进行代理，轮询每个`socket`。

`epoll` 轮询每个事件，告知事件的类型，只关心“活跃”的链接，无需遍历全部描述符集合。

[epoll原理图解](https://blog.csdn.net/qq_35433716/article/details/85345907)

5. 进程的逻辑地址空间划分

[Linux进程地址空间学习(一)](http://www.choudan.net/2013/10/24/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0(%E4%B8%80).html)

6. 线程的切换和进程的切换有什么不同

线程上下文切换的虚拟内存空间依然是相同的，但是进程切换是不同的。

线程上下文切换比进程上下文切换快的多。

7. 死锁的必要条件

- 1) 互斥条件。

即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。

- 2) 不可抢占条件。

进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。

- 3) 占有且申请条件。

进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

- 4) 循环等待条件。

存在一个进程等待序列`{P1，P2，...，Pn}`，其中`P1`等待`P2`所占有的某一资源，`P2`等待`P3`所占有的某一源，...，而`Pn`等待`P1`所占有的的某一资源，形成一个进程循环等待环。

上面的四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。

8. 进程通信方式，进程的调度方式

通信方式

- 1) 管道通信

普通管道`PIPE`：通常有两种限制，一是单工，只能单向传输；二是只能在父子或者兄弟进程间使用；

流管道`s_pipe`: 去除了第一种限制，为半双工，可以双向传输；

命名管道`name_pipe`：去除了第二种限制，可以在许多并不相关的进程之间进行通讯。

- 2) 信号量

常作为一种锁机制，用于多线程之间的同步。

- 3) 信号

通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

- 4) 消息队列

- 5) 共享内存

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。最快的`IPC`(进程间通信)方式

- 6) 套接字

客户端和服务器通信。

9. `Linux`进程用户内存空间和内核空间

操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

内核态与用户态：

- 1) 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（`0`级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

- 2) 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（`3`级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

10. `IO`多路复用

11. 写一个守护进程

守护进程(`daemon`)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

```bash
#!/bin/sh

#添加本地执行路径
export LD_LIBRARY_PATH=./

while true; do
        # 启动一个循环，定时检查进程是否存在
        server=`ps aux | grep myServer | grep -v grep`
        if [ ! "$server" ]; then
            # 如果不存在就重新启动
            nohup ./myServer -c 1 &
            # 启动后沉睡10s
            sleep 10
        fi
        # 每次循环沉睡1s
        sleep 5
done
```

# 网络

1. `Keep-Alive`模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？

[HTTP Keep-Alive模式,客户端如何判断服务器的数据已经发生完成](https://www.zhoulujun.cn/html/webfront/SGML/web/2015_1016_318.html)

使用消息首部字段`Conent-Length`：`Conent-Length`表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。

使用消息首部字段`Transfer-Encoding`：当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过`Content-length`消息首部字段告诉客户端需要接收多少数据。

但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用`Transfer-Encoding`：`chunk`模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用`Transfer-Encoding: chunked`这样的方式来代替`Content-Length`。

`chunk`编码将数据分成一块一块的发生。`Chunked`编码将使用若干个`Chunk`串连而成，由一个标明长度为`0`的`chunk`标示结束。每个`Chunk`分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(`CRLF`)隔开。在最后一个长度为`0`的`Chunk`中的内容是称为`footer`的内容，是一些附加的`Header`信息（通常可以直接忽略）。

2. `TCP`和`UDP`的特点，`TCP`三次握手、四次挥手，`TCP`连接、断开时一些标志位的改变

[TCP协议](https://github.com/JasonJe/full-stack-notes/blob/master/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.md#133-tcp%E5%8D%8F%E8%AE%AE)

[UDP协议](https://github.com/JasonJe/full-stack-notes/blob/master/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.md#134-udp%E5%8D%8F%E8%AE%AE)

3. 在浏览器中输入一个网站，发生的事情

[从输入URL到打开网页](https://github.com/JasonJe/full-stack-notes/blob/master/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5.md)

4. `HTTPS`和`HTTP`的区别，`HTTPS`属于哪个端口，`FTP`呢

`HTTPS`和`HTTP`的区别主要如下：

- 1) `https`协议需要到`ca`申请证书，一般免费证书较少，因而需要一定费用。

- 2) `http`是超文本传输协议，信息是明文传输，`https`则是具有安全性的`ssl`加密传输协议。

- 3) `http`和`https`使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。

- 4) `http`的连接很简单，是无状态的；`HTTPS`协议是由`SSL+HTTP`协议构建的可进行加密传输、身份认证的网络协议，比`http`协议安全。

[HTTP协议](https://github.com/JasonJe/full-stack-notes/blob/master/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.md#135-http%E5%8D%8F%E8%AE%AE)

[FTP和SMTP协议](https://github.com/JasonJe/full-stack-notes/blob/master/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.md#136-ftp%E5%92%8Csmtp%E5%8D%8F%E8%AE%AE)

5. `RESTful`概念

[理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)

[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)

6. `XML/JSON/Protobuf` 网络通信技术数据交换格式

- 1) `JSON`：键值对，轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。 

- 2) `XML`： 在`WebService`中应用最为广泛，但是相比于`JSON`，它的数据更加冗余，因为需要成对的闭合标签。

- 3) `Protobuf`：谷歌开源的一种数据格式，适合高性能，对响应速度有要求的数据传输场景。因为`Protobuf`是二进制数据格式，需要编码和解码。数据本身不具有可读性。因此只能反序列化之后得到真正可读的数据。

`Protobuf`优势：

- 1) 序列化后体积相比`JSON`和`XML`很小，适合网络传输；

- 2) 支持跨平台多语言；

- 3) 消息格式升级和兼容性还不错；

- 4) 序列化反序列化速度很快，快于Json的处理速度。

7. `Web Server` 性能调优、大规模并发、缓存机制

[分布式、高并发、多线程，到底有什么区别？](https://www.toutiao.com/i6658590265218957836/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1552700876&app=news_article&utm_source=weixin&utm_medium=toutiao_android&group_id=6658590265218957836)

8. `cookie` 和 `session` 的用法和区别 

- 1) `session` 保存在服务器端，`cookie` 保存在客户端；

- 2) `session` 的运行依赖 `session id`，而 `session id` 是存在 `cookie` 中的，也就是说，如果浏览器禁用了 `cookie` ，同时 `session` 也会失效（但是可以通过其它方式实现，比如在 `url` 中传递 `session_id`）；

- 4) `cookie`可以跟踪会话，也可以保存用户喜好或者保存用户名密码；`session`用来跟踪会话。

9. `cookie` 存储路径

# 数据库

1. 乐观锁和悲观锁

[常见的并发控制](https://github.com/JasonJe/full-stack-notes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#513-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)

2. 数据库范式

[关系型数据库设计](https://github.com/JasonJe/full-stack-notes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#515-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1)

3. 事务的隔离级别

[事务](https://github.com/JasonJe/full-stack-notes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#511-%E4%BA%8B%E5%8A%A1)

4. 索引，覆盖索引



5. `MySQL`存储引擎

[存储引擎](https://github.com/JasonJe/full-stack-notes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.md#536-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)

6. `MySQL`，`count(1)`, `count(*)`, `count(col)` 的区别

`count(*)`、`count(1)` 都会对全表进行扫描，统计所有记录的条数，包括那些为`null`的记录。

`count(col)` 会统计该字段不为null的记录条数。

- 1) 在表没有主键时，`count(1)`比`count(*)`快；

- 2) 有主键时，主键作为计算条件，`count(主键)`效率最高；

- 3) 若表格只有一个字段，则`count(*)`效率较高。

7. 数据库原理和常用性能优化技术

[查询性能优化](https://github.com/JasonJe/full-stack-notes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.md#535-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)

# Python 相关

1. 装饰器（什么是`AOP`/面向切面编程）

```python
#-*- coding: UTF-8 -*-
import time
 
def timeit(func):
    def wrapper():
        start = time.clock()
        func()
        end =time.clock()
        print('used:', end - start)
    return wrapper
 
@timeit # foo = timeit(foo)
def foo():
    print 'in foo()'
 
foo()
```

面向切面编程(`AOP`)，主要实现的是将业务逻辑处理过程以切面为维度进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。

也就是说，在不修改函数`A`的前提下，在函数`A`前后插入业务逻辑`B, C, D...`来减少代码的耦合度。

2. 迭代器与生成器的区别什么

迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。

迭代器协议：即对象实现了`__iter__()`和`__next__()`两个方法

可迭代对象：实现了`__iter__()`方法，无`__next__()`方法

生成器：一个包含有`yield`的函数，同时也是一个迭代器，是特殊的一种迭代器

迭代器（多迭代）：可以多次迭代；生成器（单迭代）：只能迭代一次

3. `Python`代码执行原理

运行`Python`文件程序的时候，`Python`解释器将源代码转换为字节码，然后再由`Python`解释器来执行这些字节码。

词法分析 --> 语法分析 --> 生成字节码(`.pyc`文件) --> 执行

4. `Python`的`int`是怎么实现的

`PyIntObject`结构体表示：

```python
typedef struct {
    PyObject_HEAD
    long ob_ival;
} PyIntObject;
```

`PyObject_HEAD`宏中定义的两个属性分别是：

```python
int ob_refcnt;        
struct _typeobject *ob_type;
```

这两个属性是所有`Python`对象固有的：

* `ob_refcnt`：对象的引用计数，与`Python`的内存管理机制有关，它实现了基于引用计数的垃圾收集机制
* `ob_type`：用于描述`Python`对象的类型信息。

`PyIntObject`就是一个对`C`语言中`long`类型的数值的扩展。

出于性能考虑,对于小整数，`Python`使用小整数对象池`small_ints`缓存了`[-5，257）`之间的整数，该范围内的整数在`Python`系统中是共享的。

而超过该范围的整数即使值相同，但对象不一定是同一个，如下所示：当`a`与`b`的值都是`10000`，但并不是同一个对象，而值为`1`的时候，`a`和`b`属于同一个对象。

```python
>>> a = 1
>>> b = 1
>>> a is b
True
>>> a = 10000
>>> b = 10000
>>> a is b
False
```

对于超出了`[-5, 257)`之间的其他整数，`Python`同样提供了专门的缓冲池，供这些所谓的大整数使用，避免每次使用的时候都要不断的`malloc`分配内存带来的效率损耗。这块内存空间就是`PyIntBlock`。

```python
struct _intblock {

    struct _intblock *next;
    PyIntObject objects[N_INTOBJECTS];
};
typedef struct _intblock PyIntBlock;

static PyIntBlock *block_list = NULL;
static PyIntObject *free_list = NULL;
```

这些内存块（`PyIntBlock`）通过一个单向链表组织在一起，表头是`block_list`，表头始终指向最新创建的`PyIntBlock`对象。

`PyIntBlock`有两个属性：`next`，`objects`。`next`指针指向下一个`PyIntBlock`对象，`objects`是一个`PyIntObject`数组（最终会转变成单向链表），它是真正用于存储被缓存的`PyIntObjet`对象的内存空间。

`free_list`单向链表是所有`PyIntBlock`内存块中空闲的内存。所有空闲内存通过一个链表组织起来的好处就是在`Python`需要新的内存来存储新的`PyIntObject`对象时，能够通过`free_list`快速获得所需的内存。

创建一个整数对象时，如果它在小整数范围内，就直接从小整数缓冲池中直接返回，如果不在该范围内，就开辟一个大整数缓冲池内存空间：

```python
[intobject.c]
PyObject* PyInt_FromLong(long ival)
{
     register PyIntObject *v; 
#if NSMALLNEGINTS + NSMALLPOSINTS > 0
     //[1] ：尝试使用小整数对象池
     if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {
        v = small_ints[ival + NSMALLNEGINTS];
        Py_INCREF(v);
        return (PyObject *) v;
    }
#endif
    //[2] ：为通用整数对象池申请新的内存空间
    if (free_list == NULL) {
        if ((free_list = fill_free_list()) == NULL)
            return NULL;
    }
    //[3] : (inline)内联PyObject_New的行为
    v = free_list;
    free_list = (PyIntObject *)v->ob_type;
    PyObject_INIT(v, &PyInt_Type);
    v->ob_ival = ival;
    return (PyObject *) v;
}
```

`fill_free_list`就是创建大整数缓冲池内存空间的逻辑，该函数返回一个`free_list`链表，当整数对象`ival`创建成功后，`free_list`表头就指向了`v->ob_type`，`ob_type`不是所有`Python`对象中表示类型信息的字段吗？怎么在这里作为一个连接指针呢？这是`Python`在性能与代码优雅之间取中庸之道，对名称的滥用，放弃了对类型安全的坚持。把它理解成指向下一个`PyIntObject`的指针即可。

```python
[intobject.c]
static PyIntObject* fill_free_list(void)
{
    PyIntObject *p, *q;
    // 申请大小为sizeof(PyIntBlock)的内存空间
    // block list始终指向最新创建的PyIntBlock
    p = (PyIntObject *) PyMem_MALLOC(sizeof(PyIntBlock));
    ((PyIntBlock *)p)->next = block_list;
    block_list = (PyIntBlock *)p;

    //：将PyIntBlock中的PyIntObject数组(objects)转变成单向链表
    p = &((PyIntBlock *)p)->objects[0];
    q = p + N_INTOBJECTS;
    while (--q > p)
        // ob_type指向下一个未被使用的PyIntObject。
        q->ob_type = (struct _typeobject *)(q-1);
    q->ob_type = NULL;
    return p + N_INTOBJECTS - 1;
}
```

不同的`PyIntBlock`里面的空闲的内存是怎样连接起来构成`free_list`的呢？这个秘密放在了整数对象垃圾回收的时候，在`PyIntObject`对象的`tp_dealloc`操作中可以看到：

```python
[intobject.c]
static void int_dealloc(PyIntObject *v)
{
    if (PyInt_CheckExact(v)) {
        v->ob_type = (struct _typeobject *)free_list;
        free_list = v;
    }
    else
        v->ob_type->tp_free((PyObject *)v);
}
```

原来`PyIntObject`对象销毁时，它所占用的内存并不会释放，而是继续被`Python`使用，进而将`free_list`表头指向了这个要被销毁的对象上。

5. 解释`Python`的对象

`Python`处处皆对象，`Python`中有“名字空间”的概念，这类似于其他编程语言中的作用域。在`Python`中，名字空间底层由一个`dict`实现，变量名就是字典中的键，而变量引用的对象就是字典中键对应的值。

[深入理解python之对象系统](https://www.jianshu.com/p/1a6dd03e8d82)

`Python`中最为特殊的是，类型也是一个对象，包括`Object`在内的所有类型，都是对象实例。

类型的对象的类型叫做元类，元类默认是一个`type`类对象，或者某个继承自`type`的类对象。最后，`type`类对象的类型是`type`自身。

6. 如何自己实现一个字典

```python
import collections

class MyDict(collections.UserDict):
    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def __contains__(self, key):
        return str(key) in self.data

    def __setitem__(self, key, item):
        self.data[str(key)] = item

    def __getattr__(self, key):
        return self.data[str(key)]
```

7. 什么是`GIL`、为什么要加`GIL`、如何理解`Python`多线程

`GIL`的全称为`Global Interpreter Lock`，全局解释器锁。

在任意时刻只有一个线程在解释器中运行。对`Python`虚拟机访问的控制由全局解释锁`GIL`控制，正是这个锁来控制同一时刻只有一个线程能够运行。

`Python`在同一时刻只能跑一个线程，这样在跑多线程的情况下，只有当线程获取到全局解释器锁后才能运行，而全局解释器锁只有一个，因此即使在多核的情况下也只能发挥出单核的功能。

标准模块、第三方的扩展模块，在进行密集计算任务时就会释放`GIL`。

纯计算，没有`IO`操作的程序，解释器会每隔`100`次或每隔一定时间`15ms`去释放`GIL`。

在做`IO`操作时，`GIL`总是被释放。对所有面对内建的操作系统`C`代码的程序来说，`GIL`会在`IO`调用之前被释放，以允许其它的线程在等待`IO`的时候运行。

多线程环境中，python虚拟机按照以下方式执行：

设置`GIL` --> 切换到一个线程去执行 --> 运行代码(两种机制进行`GIL`释放) --> 把线程设置为睡眠状态 --> 解锁`GIL` --> 再次重复以上步骤

用`ctypes`写`Python`代码就能绕过`GIL`，`ctypes`会在调用`C`函数前释放`GIL`。

8. 什么是协程

协程，即语言自己实现一个函数调度，在一个函数运行时，中断函数，并且保存函数上下文，之后在运行其他函数，之后再返回运行原函数。

9. 什么是上下文管理器

上下文即程序运行的环境状态。

上下文管理器的常用于一些资源的操作，需要在资源的获取与释放相关的操作。

`Python`的上下文管理协议则是`__enter__()`和`__exit__()`

10. `Python`右加（`__radd__()`）

实现反射加法操作。

正常运算时，比如：`a + b`，是以`a`为主导的，这里调用了魔法方法`__add__()`。但是如果表达式中的`a`没有`__add__()`方法时，就会调用`b`的反运算方法`__radd__()`。 

```python
>>> class Nint(int):
...     def __radd__(self, other):
...             return int.__sub__(self, other) # 剪法运算
...
>>> a = Nint(6)
>>> b = Nint(4)
>>> a + b
10
>>> 1 + b # 1 没有 __add__()方法，就调用 b 中的反运算方法 __radd__()，返回 int.__sub__(4, 1)
3
>>>
```

11. 什么是闭包

>
>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。
>

```python
>>> def print_msg():
...     msg = "test" # 局部变量
...     def printer():
...         print(msg)
...     return printer
... 
>>> another = print_msg()
>>> another() # 输出 test
>>> test
```

闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。闭包使得局部变量在函数外被访问成为可能。

12. `Python`中一般的类都继承`Object`，那`Object`的父类是什么

元类`type`。

在`Python`的世界中，`Object`是父子关系的顶端，所有的数据类型的父类都是它；`type`是类型实例关系的顶端，所有对象都是它的实例的。

它们两个的关系可以这样描述：`Object`是`type`的实例，`type`是`Object`的子类，因此`type`也是`type`自身的实例。

![](../assets/images/interview_python_12.png)

13. 谈谈元类、元类的应用

定制化类及其子类的行为。

[Python学习之路41-元类](https://juejin.im/post/5b374945e51d4558882164aa)

14. 用`Python`写一个单例模式

>
>单例模式，也叫单子模式，是一种常用的软件设计模式。 在应用这个模式时，单例对象的类必须保证只有一个实例存在。 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。
>

```python
class Single(object):
    _instance = None
    def __new__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = object.__new__(cls, *args, **kw)
        return cls._instance
    def __init__(self):
        pass

single1 = Single()
single2 = Single()
print(id(single1) == id(single2))
```

15. 谈谈`super()`原理

```python
def super(cls, inst):
    mro = inst.__class__.mro() # inst负责生成MRO的list
    return mro[mro.index(cls) + 1] # 定位到当前cls在MRO中的位置，然后后移一位，返回此处的类
```

16. 什么是多重继承

经典类中MRO搜索采用简单的从左到右的深度优先顺序，而新式类是广度优先。

17. 浅复制和深复制有什么区别

浅拷贝仅仅复制了容器中元素的地址

深拷贝，完全拷贝了一个副本，容器内部元素地址都不一样

18. `MVC/MTV`介绍

`Web`架构的模式。把业务逻辑、模型数据、用户界面分离开来，让开发者将数据与表现解耦。

`MVC`：

* `Model` 代表数据存取层；

* `Views` 代表的是系统中选择显示什么和怎么显示的部分；

* `Controller` 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。

`MTV`：

* `Models` 数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效，是一个抽象层，用来构建和操作你的web应用中的数据，模型是你的数据的唯一的、权威的信息源。它包含你所储存数据的必要字段和行为。通常，每个模型对应数据库中唯一的一张表；

* `Templates` 即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。模板层提供了设计友好的语法来展示信息给用户。使用模板方法可以动态地生成HTML。模板包含所需HTML 输出的静态部分，以及一些特殊的语法，描述如何将动态内容插入；

* `Views` 业务逻辑层，该层包含存取模型及调取恰当模板的相关逻辑。用于封装负责处理用户请求及返回响应的逻辑。视图可以看作是前端与数据库的中间人，他会将前端想要的数据从数据库中读出来给前端。他也会将用户要想保存的数据写到数据库。

19. 面向对象的三个特性

封装、继承、多态

20. `gevent`底层实现原理，协程上下文切换实现。异步`IO`。

[谈谈Python协程技术的演进](https://segmentfault.com/a/1190000012291369#articleHeader7)

`gevent`是基于`greenlet`实现。通过栈的复制切换来实现不同协程之间的切换。

`Python`基于`yield`实现协程。

1) 事件循环 (`event loop`)。事件循环需要实现两个功能，一是顺序执行协程代码；二是完成协程的调度，即一个协程“暂停”时，决定接下来执行哪个协程。

2) 协程上下文的切换。基本上`Python` 生成器的 `yield` 已经能完成切换，`Python3`中还有特定语法支持协程切换。

21. `Python` 绕过 `GIL` 加速方案