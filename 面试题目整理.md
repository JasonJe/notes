# 算法

1. 在列表中寻找第 `k` 大的数

快排 `NlgN`

最小堆 `NlgN`

构造一个大小为`k`的最小堆，堆中根节点为最小值

2. 全排列
```python
# 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
#
# 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
#
# 必须原地修改，只允许使用额外常数空间。
#
# 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
#
# 1,2,3 → 1,3,2
# 3,2,1 → 1,2,3
# 1,1,5 → 1,5,1
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums) - 1, -1, -1):
            if nums[i - 1] < nums[i]:
                position = i - 1
                for j in range(len(nums) - 1, position - 1, -1):
                    if nums[i] < nums[j]:
                        nums[i], nums[j] = nums[j], nums[i]
                        nums[i + 1:] = nums[:i:-1]
                        break
        print(nums)

class Solution(object):
    def reverse(self, nums, st):
        lena = len(nums)
        for i in range(st, st+int((lena-st)/2)):
            nums[i], nums[lena-(i-st)-1] = nums[lena-(i-st)-1], nums[i]

    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        lena = len(nums)
        for i in range(1, lena):
            ri = lena-i-1
            if nums[ri] < nums[ri+1]:
                j = ri+1
                while j < lena and nums[j] > nums[ri]:
                    j += 1
                j -= 1
                nums[ri], nums[j] = nums[j], nums[ri]
                self.reverse(nums, ri+1)
                print(nums)
                return

        nums.sort()


if __name__ == '__main__':
    sol = Solution()
    nums = [1, 2]
    data = sol.nextPermutation(nums)
    print(data)
```

3. 统计字符串中每个单词出现的个数

```python
char_dict = {}
for i in string:
	if i not in char_dict:
		char_dict.update({
			i: 1
		})
	else:
		char_dict[i] += 1
print(char_dict)
```

4. 两点连成的线段，看是否相交

`(1, 1) -- (6, 6)`，`(1, 4) -- (8, 2)`

判断两线段为对角线的矩形是否相交，若不相交，则两线段一定不相交

而判断两个矩形是否相交，只要任一矩形的最右端都大于另一矩形的最左端且任一矩形最高端大于另一矩形的最低端，则两矩形相交；反之，若其中任一条件不满足，两矩形不相交。

5. `KMP`算法

```python
def partial_table(pattern):
    prefix = set()
    table = [0]
    for i in range(1, len(pattern)):
        prefix.add(pattern[:i])
        suffix = set()
        for j in range(i, 0, -1):
            suffix.add(pattern[j:i + 1]) # 后缀
        intersection = prefix & suffix # 交集
        if intersection:
            table.append(max([len(s) for s in intersection]))
        else:
            table.append(0)
    return table

def kmp(pattern, string):
    p = len(pattern)
    s = len(string)
    cursor = 0
    table = partial_table(pattern)
    while cursor <= s - p: # 当指针到达边缘，长度不够跳出
        for i in range(p):
            if pattern[i] != string[cursor + i]:
                cursor += max(i - table[i - 1], 1) # 移动位数 = 已匹配的字符数 - 对应的部分匹配值
                break
        else:
            return cursor
    return -1
```

6. 二叉树

7. 计算复杂度，求`f(n)=n*f(n-1)+O(n)`的通项

8. 通配符匹配

https://leetcode-cn.com/problems/wildcard-matching/description/

9. 十六进制字符串和十进制字符串的相互转换

10. 把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，不能申请额外的空间

设置两个下标`p1`、`p2`

同时指向字符串的末尾，让`p1`找到第一次出现为大写的字母的位置，然后从`p1`至`p2`两两交换，之后让`p1--`，`p2--`，重复以上，直到`p1`小于`0`为止

11. `0` 到 `9999` 这 `1` 万个数中有多少个数字 `7` ？（请不要理解为多少个数包含 7）

总共有四位数，每位数的可能分别有`10`种（`0～9`）。 

每一个位，都会出现`0-9`的交替，实际上在出现`7`这个角度，各个位是一样的。

现在假设个位固定为`7`，那么其他的位数的变化数量是`10 * 10 * 10 = 1000`种。 
就是说数字`7`在个位出现的次数为`1000`。

以此类推，数字`7`在十位、百位、千位出现的次数也是`1000`。

故答案为 `4 * 1000 = 4000`

12. 有`1`亿个`IP`地址，怎么找出访问次数最多的`IP`

`IP`地址是由`32`位二进制数据来表示的，每`8`位表示一段，共有四段。四段自然就是`4×8=32`位了。

所以其最多有`2^32=4G`种取值可能，所以不能完全加载到内存中

先做`hash`，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数,
然后找出上一步求出的数据中重复次数最多的一个就是所求。

分而治之

`map`：

按照`IP`地址的`hash(IP)%1024`值，将海量日志存储到`1024`个小文件中，每个小文件最多包含`4M`个IP地址。
 
`reduce`：

对于每个小文件，可以构建一个`IP`作为`key`，出现次数作为`value`的`hash_map`，并记录当前出现次数最多的`1`个`IP`地址。 
有了`1024`个小文件中的出现次数最多的`IP`，就可以轻松得到总体上出现次数最多的`IP`。

13. 复杂链表的复制

# 操作系统

1. 进程和线程区别

2. 多线程和锁

3. 生产者消费者队列

4. `epoll`的底层实现原理

5. 进程的逻辑地址空间划分

6. 线程的切换和进程的切换有什么不同

7. 死锁的必要条件

8. 进程通信方式，进程的调度方式，写一个守护进程

9. `Linux`进程用户内存空间和内核空间

10. `IO`多路复用

# 网络

1. `Keep-Alive`模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？

[HTTP Keep-Alive模式,客户端如何判断服务器的数据已经发生完成](https://www.zhoulujun.cn/html/webfront/SGML/web/2015_1016_318.html)

使用消息首部字段`Conent-Length`：`Conent-Length`表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。

使用消息首部字段`Transfer-Encoding`：当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过`Content-length`消息首部字段告诉客户端需要接收多少数据。

但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用`Transfer-Encoding`：`chunk`模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用`Transfer-Encoding: chunked`这样的方式来代替`Content-Length`。

`chunk`编码将数据分成一块一块的发生。`Chunked`编码将使用若干个`Chunk`串连而成，由一个标明长度为`0`的`chunk`标示结束。每个`Chunk`分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(`CRLF`)隔开。在最后一个长度为`0`的`Chunk`中的内容是称为`footer`的内容，是一些附加的`Header`信息（通常可以直接忽略）。

2. `TCP`和`UDP`的特点，`TCP`三次握手、四次挥手，`TCP`连接、断开时一些标志位的改变

3. 在浏览器中输入一个网站，发生的事情

4. `Https`和`Http`的区别，`Https`属于哪个端口，`FTP`呢

5. `RESTful`概念

6. `xml/json/protobuf` 网络通信技术数据交换格式

7. `TCP`，`IP`，`HTTP` 网络协议

8. `Web Server` 性能调优、大规模并发、缓存机制

9. `cookie` 和 `session` 的用法和区别 

# 数据库

1. 乐观锁和悲观锁

2. 数据库范式

3. 事务的隔离级别

4. 索引，覆盖索引

5. `MySQL`存储引擎

6. `MySQL`，`count(1)`, `count(*)`, `count(col)` 的区别

7. 数据库原理和常用性能优化技术

# Python 相关

1. 装饰器（什么是`AOP`/面向切面编程）

```python
#-*- coding: UTF-8 -*-
import time
 
def timeit(func):
    def wrapper():
        start = time.clock()
        func()
        end =time.clock()
        print('used:', end - start)
    return wrapper
 
@timeit # foo = timeit(foo)
def foo():
    print 'in foo()'
 
foo()
```

面向切面编程(`AOP`)，主要实现的是将业务逻辑处理过程以切面为维度进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。

也就是说，在不修改函数`A`的前提下，在函数`A`前后插入业务逻辑`B, C, D...`来减少代码的耦合度。

2. 迭代器与生成器的区别什么

迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。

迭代器协议：即对象实现了`__iter__()`和`__next__()`两个方法

可迭代对象：实现了`__iter__()`方法，无`__next__()`方法

生成器：一个包含有`yield`的函数，同时也是一个迭代器，是特殊的一种迭代器

迭代器（多迭代）：可以多次迭代；生成器（单迭代）：只能迭代一次

3. `Python`代码执行原理

运行`Python`文件程序的时候，`Python`解释器将源代码转换为字节码，然后再由`Python`解释器来执行这些字节码。

词法分析 --> 语法分析 --> 生成字节码(`.pyc`文件) --> 执行

4. `Python`的`int`是怎么实现的

`PyIntObject`结构体表示：

```python
typedef struct {
    PyObject_HEAD
    long ob_ival;
} PyIntObject;
```

`PyObject_HEAD`宏中定义的两个属性分别是：

```python
int ob_refcnt;        
struct _typeobject *ob_type;
```

这两个属性是所有`Python`对象固有的：

* `ob_refcnt`：对象的引用计数，与`Python`的内存管理机制有关，它实现了基于引用计数的垃圾收集机制
* `ob_type`：用于描述`Python`对象的类型信息。

`PyIntObject`就是一个对`C`语言中`long`类型的数值的扩展。

出于性能考虑,对于小整数，`Python`使用小整数对象池`small_ints`缓存了`[-5，257）`之间的整数，该范围内的整数在`Python`系统中是共享的。

而超过该范围的整数即使值相同，但对象不一定是同一个，如下所示：当`a`与`b`的值都是`10000`，但并不是同一个对象，而值为`1`的时候，`a`和`b`属于同一个对象。

```python
>>> a = 1
>>> b = 1
>>> a is b
True
>>> a = 10000
>>> b = 10000
>>> a is b
False
```

对于超出了`[-5, 257)`之间的其他整数，`Python`同样提供了专门的缓冲池，供这些所谓的大整数使用，避免每次使用的时候都要不断的`malloc`分配内存带来的效率损耗。这块内存空间就是`PyIntBlock`。

```python
struct _intblock {

    struct _intblock *next;
    PyIntObject objects[N_INTOBJECTS];
};
typedef struct _intblock PyIntBlock;

static PyIntBlock *block_list = NULL;
static PyIntObject *free_list = NULL;
```

这些内存块（`PyIntBlock`）通过一个单向链表组织在一起，表头是`block_list`，表头始终指向最新创建的`PyIntBlock`对象。

`PyIntBlock`有两个属性：`next`，`objects`。`next`指针指向下一个`PyIntBlock`对象，`objects`是一个`PyIntObject`数组（最终会转变成单向链表），它是真正用于存储被缓存的`PyIntObjet`对象的内存空间。

`free_list`单向链表是所有`PyIntBlock`内存块中空闲的内存。所有空闲内存通过一个链表组织起来的好处就是在`Python`需要新的内存来存储新的`PyIntObject`对象时，能够通过`free_list`快速获得所需的内存。

创建一个整数对象时，如果它在小整数范围内，就直接从小整数缓冲池中直接返回，如果不在该范围内，就开辟一个大整数缓冲池内存空间：

```python
[intobject.c]
PyObject* PyInt_FromLong(long ival)
{
     register PyIntObject *v; 
#if NSMALLNEGINTS + NSMALLPOSINTS > 0
     //[1] ：尝试使用小整数对象池
     if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {
        v = small_ints[ival + NSMALLNEGINTS];
        Py_INCREF(v);
        return (PyObject *) v;
    }
#endif
    //[2] ：为通用整数对象池申请新的内存空间
    if (free_list == NULL) {
        if ((free_list = fill_free_list()) == NULL)
            return NULL;
    }
    //[3] : (inline)内联PyObject_New的行为
    v = free_list;
    free_list = (PyIntObject *)v->ob_type;
    PyObject_INIT(v, &PyInt_Type);
    v->ob_ival = ival;
    return (PyObject *) v;
}
```

`fill_free_list`就是创建大整数缓冲池内存空间的逻辑，该函数返回一个`free_list`链表，当整数对象`ival`创建成功后，`free_list`表头就指向了`v->ob_type`，`ob_type`不是所有`Python`对象中表示类型信息的字段吗？怎么在这里作为一个连接指针呢？这是`Python`在性能与代码优雅之间取中庸之道，对名称的滥用，放弃了对类型安全的坚持。把它理解成指向下一个`PyIntObject`的指针即可。

```python
[intobject.c]
static PyIntObject* fill_free_list(void)
{
    PyIntObject *p, *q;
    // 申请大小为sizeof(PyIntBlock)的内存空间
    // block list始终指向最新创建的PyIntBlock
    p = (PyIntObject *) PyMem_MALLOC(sizeof(PyIntBlock));
    ((PyIntBlock *)p)->next = block_list;
    block_list = (PyIntBlock *)p;

    //：将PyIntBlock中的PyIntObject数组(objects)转变成单向链表
    p = &((PyIntBlock *)p)->objects[0];
    q = p + N_INTOBJECTS;
    while (--q > p)
        // ob_type指向下一个未被使用的PyIntObject。
        q->ob_type = (struct _typeobject *)(q-1);
    q->ob_type = NULL;
    return p + N_INTOBJECTS - 1;
}
```

不同的`PyIntBlock`里面的空闲的内存是怎样连接起来构成`free_list`的呢？这个秘密放在了整数对象垃圾回收的时候，在`PyIntObject`对象的`tp_dealloc`操作中可以看到：

```python
[intobject.c]
static void int_dealloc(PyIntObject *v)
{
    if (PyInt_CheckExact(v)) {
        v->ob_type = (struct _typeobject *)free_list;
        free_list = v;
    }
    else
        v->ob_type->tp_free((PyObject *)v);
}
```

原来`PyIntObject`对象销毁时，它所占用的内存并不会释放，而是继续被`Python`使用，进而将`free_list`表头指向了这个要被销毁的对象上。

5. 解释`Python`的对象

`Python`处处皆对象，`Python`中有“名字空间”的概念，这类似于其他编程语言中的作用域。在`Python`中，名字空间底层由一个`dict`实现，变量名就是字典中的键，而变量引用的对象就是字典中键对应的值。

[深入理解python之对象系统](https://www.jianshu.com/p/1a6dd03e8d82)

`Python`中最为特殊的是，类型也是一个对象，包括`Object`在内的所有类型，都是对象实例。

类型的对象的类型叫做元类，元类默认是一个`type`类对象，或者某个继承自`type`的类对象。最后，`type`类对象的类型是`type`自身。

6. 如何自己实现一个字典

```python
import collections

class MyDict(collections.UserDict):
    def __missing__(self, key):
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def __contains__(self, key):
        return str(key) in self.data

    def __setitem__(self, key, item):
        self.data[str(key)] = item

    def __getattr__(self, key):
        return self.data[str(key)]
```

7. 什么是`GIL`、为什么要加`GIL`、如何理解`Python`多线程

`GIL`的全称为`Global Interpreter Lock`，全局解释器锁。

在任意时刻只有一个线程在解释器中运行。对`Python`虚拟机访问的控制由全局解释锁`GIL`控制，正是这个锁来控制同一时刻只有一个线程能够运行。

`Python`在同一时刻只能跑一个线程，这样在跑多线程的情况下，只有当线程获取到全局解释器锁后才能运行，而全局解释器锁只有一个，因此即使在多核的情况下也只能发挥出单核的功能。

标准模块、第三方的扩展模块，在进行密集计算任务时就会释放`GIL`。

纯计算，没有`IO`操作的程序，解释器会每隔`100`次或每隔一定时间`15ms`去释放`GIL`。

在做`IO`操作时，`GIL`总是被释放。对所有面对内建的操作系统`C`代码的程序来说，`GIL`会在`IO`调用之前被释放，以允许其它的线程在等待`IO`的时候运行。

多线程环境中，python虚拟机按照以下方式执行：

设置`GIL` --> 切换到一个线程去执行 --> 运行代码(两种机制进行`GIL`释放) --> 把线程设置为睡眠状态 --> 解锁`GIL` --> 再次重复以上步骤

用`ctypes`写`Python`代码就能绕过`GIL`，`ctypes`会在调用`C`函数前释放`GIL`。

8. 什么是协程

协程，即语言自己实现一个函数调度，在一个函数运行时，中断函数，并且保存函数上下文，之后在运行其他函数，之后再返回运行原函数。

9. 什么是上下文管理器

上下文即程序运行的环境状态。

上下文管理器的常用于一些资源的操作，需要在资源的获取与释放相关的操作。

`Python`的上下文管理协议则是`__enter__()`和`__exit__()`

10. 你知道右加么（`__radd__`）

11. 什么是闭包

12. `Python`中一般的类都继承`Object`，那`Object`的父类是什么

13. 谈谈元类、元类的应用

14. 用`Python`写一个单例模式

15. 谈谈`super`原理

16. 什么是多重继承

17. 浅复制和深复制有什么区别

18. `MVC/MTV`介绍

https://blog.csdn.net/enjoy_su/article/details/78864638

19. 面向对象的三个特性

20. 基本的设计模型

21. `gevent`底层实现原理，协程上下文切换实现。异步`IO`。