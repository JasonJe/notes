# 操作系统

## 进程和线程区别

进程拥有独立的地址空间，线程拥有自己的堆栈和局部变量，但是线程之间没有单独的地址空间。

线程是一个进程的不同执行路径，一个程序至少有一个进程，一个进程至少有一个线程。线程不能单独执行。

进程间切换，消耗资源大，效率较差。对需要同时进行且要共享变量的并发操作，只能用线程

## 多线程和锁

多线程同时对同一个对象进行读写操作，很容易出现一些难以预料的问题，所以需要对对象进行加锁操作，在同一时刻只允许一个线程对某个对象进行操作。

* 临界资源

能够被多个线程共享的数据/资源

* 临界区

对临界资源进行操作程序

* 线程互斥

在同一时刻只允许一个进程运行其中的程序片，具有排他性和唯一性

* 线程同步

在互斥的基础上，实现进程之间的有序访问

* 互斥锁

对临界区进行保护，实现线程间的互斥

* 死锁

指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态

## 生产者消费者队列

* 生产者和消费者模式

在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

* 生产者消费者模式

生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

## `epoll`的底层实现原理

`select` 对事件进行代理，轮询每个`socket`。

`epoll` 轮询每个事件，告知事件的类型，只关心“活跃”的链接，无需遍历全部描述符集合。

[epoll原理图解](https://blog.csdn.net/qq_35433716/article/details/85345907)

## 进程的逻辑地址空间划分

[Linux进程地址空间学习(一)](http://www.choudan.net/2013/10/24/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0(%E4%B8%80).html)

## 线程的切换和进程的切换有什么不同

线程上下文切换的虚拟内存空间依然是相同的，但是进程切换是不同的。

线程上下文切换比进程上下文切换快的多。

## 死锁的必要条件

- 1) 互斥条件。

即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。

- 2) 不可抢占条件。

进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。

- 3) 占有且申请条件。

进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

- 4) 循环等待条件。

存在一个进程等待序列`{P1，P2，...，Pn}`，其中`P1`等待`P2`所占有的某一资源，`P2`等待`P3`所占有的某一源，...，而`Pn`等待`P1`所占有的的某一资源，形成一个进程循环等待环。

上面的四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。

## 进程通信方式，进程的调度方式

通信方式

- 1) 管道通信

普通管道`PIPE`：通常有两种限制，一是单工，只能单向传输；二是只能在父子或者兄弟进程间使用；

流管道`s_pipe`: 去除了第一种限制，为半双工，可以双向传输；

命名管道`name_pipe`：去除了第二种限制，可以在许多并不相关的进程之间进行通讯。

- 2) 信号量

常作为一种锁机制，用于多线程之间的同步。

- 3) 信号

通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

- 4) 消息队列

- 5) 共享内存

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。最快的`IPC`(进程间通信)方式

- 6) 套接字

客户端和服务器通信。

## `Linux`进程用户内存空间和内核空间

操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

内核态与用户态：

- 1) 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（`0`级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

- 2) 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（`3`级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

## `IO`多路复用

## 写一个守护进程

守护进程(`daemon`)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

```bash
#!/bin/sh

#添加本地执行路径
export LD_LIBRARY_PATH=./

while true; do
        # 启动一个循环，定时检查进程是否存在
        server=`ps aux | grep myServer | grep -v grep`
        if [ ! "$server" ]; then
            # 如果不存在就重新启动
            nohup ./myServer -c 1 &
            # 启动后沉睡10s
            sleep 10
        fi
        # 每次循环沉睡1s
        sleep 5
done
```