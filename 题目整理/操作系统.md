# 操作系统

## 进程和线程区别 :star:

进程拥有独立的地址空间，线程拥有自己的堆栈和局部变量，但是线程之间没有单独的地址空间。

线程是一个进程的不同执行路径，一个程序至少有一个进程，一个进程至少有一个线程。线程不能单独执行。

进程间切换，消耗资源大，效率较差。对需要同时进行且要共享变量的并发操作，只能用线程

## 多线程和锁

多线程同时对同一个对象进行读写操作，很容易出现一些难以预料的问题，所以需要对对象进行加锁操作，在同一时刻只允许一个线程对某个对象进行操作。

* 临界资源

能够被多个线程共享的数据/资源

* 临界区

对临界资源进行操作程序

* 线程互斥

在同一时刻只允许一个进程运行其中的程序片，具有排他性和唯一性

* 线程同步

在互斥的基础上，实现进程之间的有序访问

* 互斥锁

对临界区进行保护，实现线程间的互斥

* 死锁

指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态

## 生产者消费者队列

* 生产者和消费者模式

在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

* 生产者消费者模式

生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

## `epoll`的底层实现原理

`select` 对事件进行代理，轮询每个`socket`。

`epoll` 轮询每个事件，告知事件的类型，只关心“活跃”的链接，无需遍历全部描述符集合。

[epoll原理图解](https://blog.csdn.net/qq_35433716/article/details/85345907)

## 进程的逻辑地址空间划分

[Linux进程地址空间学习(一)](http://www.choudan.net/2013/10/24/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0(%E4%B8%80).html)

## 线程的切换和进程的切换有什么不同、创建线程和进程的开销指什么

线程上下文切换的虚拟内存空间依然是相同的，但是进程切换是不同的。

线程上下文切换比进程上下文切换快的多。

## 死锁的必要条件

- 1) 互斥条件。

即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。

- 2) 不可抢占条件。

进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。

- 3) 占有且申请条件。

进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

- 4) 循环等待条件。

存在一个进程等待序列`{P1，P2，...，Pn}`，其中`P1`等待`P2`所占有的某一资源，`P2`等待`P3`所占有的某一源，...，而`Pn`等待`P1`所占有的的某一资源，形成一个进程循环等待环。

上面的四个条件在死锁时会同时发生。也就是说，只要有一个必要条件不满足，则死锁就可以排除。

## 进程通信方式，进程的调度方式，进程同步方式 :star:

* 通信方式

- 1) 管道通信

普通管道`PIPE`：通常有两种限制，一是单工，只能单向传输；二是只能在父子或者兄弟进程间使用；

流管道`s_pipe`: 去除了第一种限制，为半双工，可以双向传输；

命名管道`name_pipe`：去除了第二种限制，可以在许多并不相关的进程之间进行通讯。

- 2) 信号量

常作为一种锁机制，用于多线程之间的同步。

- 3) 信号

通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

- 4) 消息队列

- 5) 共享内存

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。最快的`IPC`(进程间通信)方式

- 6) 套接字

客户端和服务器通信。

* 调度方式

`Linux`内核的三种主要调度策略

1) 分时调度策略

创建任务指定采用分时调度策略，并指定优先级`nice`值（`-20 ~ 19`）；

根据每个任务的`nice`值确定在`CPU`上的执行时间(`counter`)；

如果没有等待资源，将该任务加入到就绪队列中；

调度程序遍历就绪队列中的任务，通过对每个任务动态优先级地计算权值(`counter + 20 - nice`)，选择一个计算结果最大的一个去运行，当时间片用完后(`counter = 0`)或者主动放弃`CPU`时，该任务就被放在就绪队列末尾，或者等待队列中。

2) 实时调度策略，先到先服务

创建进程是指定采用`FIFO`，并设置实时优先级`rt_priority`(`1~99`)；

如果没有等待资源，将该任务加入到就绪队列中；

调度程序遍历就绪队列，根据实时优先级计算调度权值(`1000 + rt_priority`)，选择权值最高的任务使用`CPU`，该`FIFO`任务将一直占有`CPU`直到有优先等级更高的任务就绪或者主动放弃；

调度程序发现有优先级更高的任务到达，则立即在当前任务堆栈中保存当前`CPU`寄存器的所有数据，重新从高优先级任务的堆栈中加载寄存器数据到`CPU`，此时高优先级任务开始运行；

如果当前任务因等待资源而主动放弃`CPU`使用权，则该任务将从就绪队列中删除，加入等待队列。

3) 实时调度策略，时间片轮转

创建任务时指定调度参数为`PR`，并设置任务实时优先级和`nice`值；

如果没有等待资源，将该任务加入到就绪队列中；

调度程序遍历就绪队列，根据实时优先级计算调度权值(`1000 + rt_priority`)，选择权值最高的任务使用`CPU`；

如果就绪队列中的`PR`任务时间片为`0`，则会根据`nice`值设置该任务的时间片，同时将该任务放入就绪队列的末尾；

当前任务由于等待资源而主动退出`CPU`，则将其加入等待队列中。

* 同步方式

临界区（`Critical Section`）

通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

互斥量（`Mutex`）

为协调共同对一个共享资源的单独访问而设计的。

信号量（`Semaphore`）

为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的`最大资源数=1`就是互斥量了。

事件（`Event`）

用来通知线程有一些事件已发生，从而启动后继任务的开始。


## `Linux`进程用户内存空间和内核空间

操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

内核态与用户态：

- 1) 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（`0`级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

- 2) 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（`3`级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。

## 写一个守护进程

守护进程(`daemon`)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

```bash
#!/bin/sh

#添加本地执行路径
export LD_LIBRARY_PATH=./

while true; do
        # 启动一个循环，定时检查进程是否存在
        server=`ps aux | grep myServer | grep -v grep`
        if [ ! "$server" ]; then
            # 如果不存在就重新启动
            nohup ./myServer -c 1 &
            # 启动后沉睡10s
            sleep 10
        fi
        # 每次循环沉睡1s
        sleep 5
done
```

## 线程的生命周期

新建(`New`)、就绪（`Runnable`）、运行（`Running`）、阻塞(`Blocked`)和死亡(`Dead`)5种状态。

## `ACID`、`CAP`、`BASE`理论

[事务](https://github.com/JasonJe/full-stack-notes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%##md#511-%E4%BA%8B%E5%8A%A1)

* `CAP`

一个分布式系统不可能同时满足一致性（`C:Consistency`）、可用性（`A:Availability`）和分区容错性（`P:Partition tolerance`）这三个基本要求，最多只能满足其中的两项。

放弃`P`：

如果希望能够避免系统出现分区容错性问题，一种较为简单的做法是将所有的数据（或者仅仅是哪些与事务相关的数据）都放在一个分布式节点上。这样做虽然无法100%保证系统不会出错，但至少不会碰到由于网络分区带来的负面影响。但同时需要注意的是，放弃P的同时也就意味着放弃了系统的可扩展性

放弃`A`：

一旦系统遇到网络分区或其他故障或为了保证一致性时，放弃可用性，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供正常的服务，即不可用

放弃`C`：

这里所说的放弃一致性，实际上指的是放弃数据的强一致性，而保留数据的最终一致性。这样的系统无法保证数据保持实时的一致性，但是能够承诺的是，数据最终会达到一个一致的状态。

* `BASE`

BASE是`Basically Available`(基本可用）、`Soft state`(软状态）和`Eventually consistent`(最终一致性）。

其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方法来使系统达到最终一致性。

`BA`：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。

`S`：允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同的数据副本之间进行数据同步的过程存在延时。

`E`：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。

## `Docker`和虚拟机的区别

从虚拟化层面来看，传统虚拟化技术是对硬件资源的虚拟，容器技术则是对进程的虚拟，从而可提供更轻量 级的虚拟化，实现进程和资源的隔离。

从架构来看，`Docker`比虚拟化少了两层，取消了`Hypervisor`层和`GuestOS`层，使用 `Docker Engine` 进行调度和隔离，所有应用共用主机操作系统，因此在体量上，`Docker`较虚拟机更轻量级，在性能上优于虚拟化，接近裸机性能。

## `Linux`的共享内存的实现

## `IO`多路复用